// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/tsisar/starknet-indexer/generated/ent/block"
	"github.com/tsisar/starknet-indexer/generated/ent/meta"
	"github.com/tsisar/starknet-indexer/generated/ent/pool"
	"github.com/tsisar/starknet-indexer/generated/ent/position"
	"github.com/tsisar/starknet-indexer/generated/ent/positionactivity"
	"github.com/tsisar/starknet-indexer/generated/ent/predicate"
	"github.com/tsisar/starknet-indexer/generated/ent/protocolstat"
	"github.com/tsisar/starknet-indexer/generated/ent/stableswapstat"
	"github.com/tsisar/starknet-indexer/generated/ent/swapevent"
	"github.com/tsisar/starknet-indexer/generated/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlock            = "Block"
	TypeMeta             = "Meta"
	TypePool             = "Pool"
	TypePosition         = "Position"
	TypePositionActivity = "PositionActivity"
	TypeProtocolStat     = "ProtocolStat"
	TypeStableSwapStat   = "StableSwapStat"
	TypeSwapEvent        = "SwapEvent"
	TypeUser             = "User"
)

// BlockMutation represents an operation that mutates the Block nodes in the graph.
type BlockMutation struct {
	config
	op            Op
	typ           string
	id            *int
	hash          *string
	number        *string
	parentHash    *string
	timestamp     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Block, error)
	predicates    []predicate.Block
}

var _ ent.Mutation = (*BlockMutation)(nil)

// blockOption allows management of the mutation configuration using functional options.
type blockOption func(*BlockMutation)

// newBlockMutation creates new mutation for the Block entity.
func newBlockMutation(c config, op Op, opts ...blockOption) *BlockMutation {
	m := &BlockMutation{
		config:        c,
		op:            op,
		typ:           TypeBlock,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlockID sets the ID field of the mutation.
func withBlockID(id int) blockOption {
	return func(m *BlockMutation) {
		var (
			err   error
			once  sync.Once
			value *Block
		)
		m.oldValue = func(ctx context.Context) (*Block, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Block.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlock sets the old Block of the mutation.
func withBlock(node *Block) blockOption {
	return func(m *BlockMutation) {
		m.oldValue = func(context.Context) (*Block, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlockMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlockMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlockMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlockMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Block.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetHash sets the "hash" field.
func (m *BlockMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *BlockMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *BlockMutation) ResetHash() {
	m.hash = nil
}

// SetNumber sets the "number" field.
func (m *BlockMutation) SetNumber(s string) {
	m.number = &s
}

// Number returns the value of the "number" field in the mutation.
func (m *BlockMutation) Number() (r string, exists bool) {
	v := m.number
	if v == nil {
		return
	}
	return *v, true
}

// OldNumber returns the old "number" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumber: %w", err)
	}
	return oldValue.Number, nil
}

// ResetNumber resets all changes to the "number" field.
func (m *BlockMutation) ResetNumber() {
	m.number = nil
}

// SetParentHash sets the "parentHash" field.
func (m *BlockMutation) SetParentHash(s string) {
	m.parentHash = &s
}

// ParentHash returns the value of the "parentHash" field in the mutation.
func (m *BlockMutation) ParentHash() (r string, exists bool) {
	v := m.parentHash
	if v == nil {
		return
	}
	return *v, true
}

// OldParentHash returns the old "parentHash" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldParentHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentHash: %w", err)
	}
	return oldValue.ParentHash, nil
}

// ResetParentHash resets all changes to the "parentHash" field.
func (m *BlockMutation) ResetParentHash() {
	m.parentHash = nil
}

// SetTimestamp sets the "timestamp" field.
func (m *BlockMutation) SetTimestamp(s string) {
	m.timestamp = &s
}

// Timestamp returns the value of the "timestamp" field in the mutation.
func (m *BlockMutation) Timestamp() (r string, exists bool) {
	v := m.timestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldTimestamp returns the old "timestamp" field's value of the Block entity.
// If the Block object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlockMutation) OldTimestamp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimestamp: %w", err)
	}
	return oldValue.Timestamp, nil
}

// ResetTimestamp resets all changes to the "timestamp" field.
func (m *BlockMutation) ResetTimestamp() {
	m.timestamp = nil
}

// Where appends a list predicates to the BlockMutation builder.
func (m *BlockMutation) Where(ps ...predicate.Block) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlockMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlockMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Block, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlockMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlockMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Block).
func (m *BlockMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlockMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.hash != nil {
		fields = append(fields, block.FieldHash)
	}
	if m.number != nil {
		fields = append(fields, block.FieldNumber)
	}
	if m.parentHash != nil {
		fields = append(fields, block.FieldParentHash)
	}
	if m.timestamp != nil {
		fields = append(fields, block.FieldTimestamp)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlockMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case block.FieldHash:
		return m.Hash()
	case block.FieldNumber:
		return m.Number()
	case block.FieldParentHash:
		return m.ParentHash()
	case block.FieldTimestamp:
		return m.Timestamp()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlockMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case block.FieldHash:
		return m.OldHash(ctx)
	case block.FieldNumber:
		return m.OldNumber(ctx)
	case block.FieldParentHash:
		return m.OldParentHash(ctx)
	case block.FieldTimestamp:
		return m.OldTimestamp(ctx)
	}
	return nil, fmt.Errorf("unknown Block field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockMutation) SetField(name string, value ent.Value) error {
	switch name {
	case block.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case block.FieldNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumber(v)
		return nil
	case block.FieldParentHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentHash(v)
		return nil
	case block.FieldTimestamp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimestamp(v)
		return nil
	}
	return fmt.Errorf("unknown Block field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlockMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlockMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlockMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Block numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlockMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlockMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlockMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Block nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlockMutation) ResetField(name string) error {
	switch name {
	case block.FieldHash:
		m.ResetHash()
		return nil
	case block.FieldNumber:
		m.ResetNumber()
		return nil
	case block.FieldParentHash:
		m.ResetParentHash()
		return nil
	case block.FieldTimestamp:
		m.ResetTimestamp()
		return nil
	}
	return fmt.Errorf("unknown Block field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlockMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlockMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlockMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlockMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlockMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlockMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlockMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Block unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlockMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Block edge %s", name)
}

// MetaMutation represents an operation that mutates the Meta nodes in the graph.
type MetaMutation struct {
	config
	op                Op
	typ               string
	id                *int
	deployment        *string
	hasIndexingErrors *string
	clearedFields     map[string]struct{}
	block             *int
	clearedblock      bool
	done              bool
	oldValue          func(context.Context) (*Meta, error)
	predicates        []predicate.Meta
}

var _ ent.Mutation = (*MetaMutation)(nil)

// metaOption allows management of the mutation configuration using functional options.
type metaOption func(*MetaMutation)

// newMetaMutation creates new mutation for the Meta entity.
func newMetaMutation(c config, op Op, opts ...metaOption) *MetaMutation {
	m := &MetaMutation{
		config:        c,
		op:            op,
		typ:           TypeMeta,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMetaID sets the ID field of the mutation.
func withMetaID(id int) metaOption {
	return func(m *MetaMutation) {
		var (
			err   error
			once  sync.Once
			value *Meta
		)
		m.oldValue = func(ctx context.Context) (*Meta, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Meta.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMeta sets the old Meta of the mutation.
func withMeta(node *Meta) metaOption {
	return func(m *MetaMutation) {
		m.oldValue = func(context.Context) (*Meta, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MetaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MetaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MetaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MetaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Meta.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeployment sets the "deployment" field.
func (m *MetaMutation) SetDeployment(s string) {
	m.deployment = &s
}

// Deployment returns the value of the "deployment" field in the mutation.
func (m *MetaMutation) Deployment() (r string, exists bool) {
	v := m.deployment
	if v == nil {
		return
	}
	return *v, true
}

// OldDeployment returns the old "deployment" field's value of the Meta entity.
// If the Meta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetaMutation) OldDeployment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeployment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeployment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeployment: %w", err)
	}
	return oldValue.Deployment, nil
}

// ResetDeployment resets all changes to the "deployment" field.
func (m *MetaMutation) ResetDeployment() {
	m.deployment = nil
}

// SetHasIndexingErrors sets the "hasIndexingErrors" field.
func (m *MetaMutation) SetHasIndexingErrors(s string) {
	m.hasIndexingErrors = &s
}

// HasIndexingErrors returns the value of the "hasIndexingErrors" field in the mutation.
func (m *MetaMutation) HasIndexingErrors() (r string, exists bool) {
	v := m.hasIndexingErrors
	if v == nil {
		return
	}
	return *v, true
}

// OldHasIndexingErrors returns the old "hasIndexingErrors" field's value of the Meta entity.
// If the Meta object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MetaMutation) OldHasIndexingErrors(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasIndexingErrors is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasIndexingErrors requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasIndexingErrors: %w", err)
	}
	return oldValue.HasIndexingErrors, nil
}

// ResetHasIndexingErrors resets all changes to the "hasIndexingErrors" field.
func (m *MetaMutation) ResetHasIndexingErrors() {
	m.hasIndexingErrors = nil
}

// SetBlockID sets the "block" edge to the Block entity by id.
func (m *MetaMutation) SetBlockID(id int) {
	m.block = &id
}

// ClearBlock clears the "block" edge to the Block entity.
func (m *MetaMutation) ClearBlock() {
	m.clearedblock = true
}

// BlockCleared reports if the "block" edge to the Block entity was cleared.
func (m *MetaMutation) BlockCleared() bool {
	return m.clearedblock
}

// BlockID returns the "block" edge ID in the mutation.
func (m *MetaMutation) BlockID() (id int, exists bool) {
	if m.block != nil {
		return *m.block, true
	}
	return
}

// BlockIDs returns the "block" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BlockID instead. It exists only for internal usage by the builders.
func (m *MetaMutation) BlockIDs() (ids []int) {
	if id := m.block; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBlock resets all changes to the "block" edge.
func (m *MetaMutation) ResetBlock() {
	m.block = nil
	m.clearedblock = false
}

// Where appends a list predicates to the MetaMutation builder.
func (m *MetaMutation) Where(ps ...predicate.Meta) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MetaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MetaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Meta, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MetaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MetaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Meta).
func (m *MetaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MetaMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.deployment != nil {
		fields = append(fields, meta.FieldDeployment)
	}
	if m.hasIndexingErrors != nil {
		fields = append(fields, meta.FieldHasIndexingErrors)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MetaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case meta.FieldDeployment:
		return m.Deployment()
	case meta.FieldHasIndexingErrors:
		return m.HasIndexingErrors()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MetaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case meta.FieldDeployment:
		return m.OldDeployment(ctx)
	case meta.FieldHasIndexingErrors:
		return m.OldHasIndexingErrors(ctx)
	}
	return nil, fmt.Errorf("unknown Meta field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case meta.FieldDeployment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeployment(v)
		return nil
	case meta.FieldHasIndexingErrors:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasIndexingErrors(v)
		return nil
	}
	return fmt.Errorf("unknown Meta field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MetaMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MetaMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MetaMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Meta numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MetaMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MetaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MetaMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Meta nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MetaMutation) ResetField(name string) error {
	switch name {
	case meta.FieldDeployment:
		m.ResetDeployment()
		return nil
	case meta.FieldHasIndexingErrors:
		m.ResetHasIndexingErrors()
		return nil
	}
	return fmt.Errorf("unknown Meta field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MetaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.block != nil {
		edges = append(edges, meta.EdgeBlock)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MetaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case meta.EdgeBlock:
		if id := m.block; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MetaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MetaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MetaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedblock {
		edges = append(edges, meta.EdgeBlock)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MetaMutation) EdgeCleared(name string) bool {
	switch name {
	case meta.EdgeBlock:
		return m.clearedblock
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MetaMutation) ClearEdge(name string) error {
	switch name {
	case meta.EdgeBlock:
		m.ClearBlock()
		return nil
	}
	return fmt.Errorf("unknown Meta unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MetaMutation) ResetEdge(name string) error {
	switch name {
	case meta.EdgeBlock:
		m.ResetBlock()
		return nil
	}
	return fmt.Errorf("unknown Meta edge %s", name)
}

// PoolMutation represents an operation that mutates the Pool nodes in the graph.
type PoolMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	poolName              *string
	debtCeiling           *string
	liquidationRatio      *string
	stabilityFeeRate      *string
	tokenAdapterAddress   *string
	lockedCollateral      *string
	collateralPrice       *string
	collateralLastPrice   *string
	priceWithSafetyMargin *string
	rawPrice              *string
	debtAccumulatedRate   *string
	totalBorrowed         *string
	totalAvailable        *string
	tvl                   *string
	clearedFields         map[string]struct{}
	positions             map[string]struct{}
	removedpositions      map[string]struct{}
	clearedpositions      bool
	done                  bool
	oldValue              func(context.Context) (*Pool, error)
	predicates            []predicate.Pool
}

var _ ent.Mutation = (*PoolMutation)(nil)

// poolOption allows management of the mutation configuration using functional options.
type poolOption func(*PoolMutation)

// newPoolMutation creates new mutation for the Pool entity.
func newPoolMutation(c config, op Op, opts ...poolOption) *PoolMutation {
	m := &PoolMutation{
		config:        c,
		op:            op,
		typ:           TypePool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPoolID sets the ID field of the mutation.
func withPoolID(id string) poolOption {
	return func(m *PoolMutation) {
		var (
			err   error
			once  sync.Once
			value *Pool
		)
		m.oldValue = func(ctx context.Context) (*Pool, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPool sets the old Pool of the mutation.
func withPool(node *Pool) poolOption {
	return func(m *PoolMutation) {
		m.oldValue = func(context.Context) (*Pool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PoolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PoolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pool entities.
func (m *PoolMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PoolMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PoolMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pool.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPoolName sets the "poolName" field.
func (m *PoolMutation) SetPoolName(s string) {
	m.poolName = &s
}

// PoolName returns the value of the "poolName" field in the mutation.
func (m *PoolMutation) PoolName() (r string, exists bool) {
	v := m.poolName
	if v == nil {
		return
	}
	return *v, true
}

// OldPoolName returns the old "poolName" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldPoolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoolName: %w", err)
	}
	return oldValue.PoolName, nil
}

// ResetPoolName resets all changes to the "poolName" field.
func (m *PoolMutation) ResetPoolName() {
	m.poolName = nil
}

// SetDebtCeiling sets the "debtCeiling" field.
func (m *PoolMutation) SetDebtCeiling(s string) {
	m.debtCeiling = &s
}

// DebtCeiling returns the value of the "debtCeiling" field in the mutation.
func (m *PoolMutation) DebtCeiling() (r string, exists bool) {
	v := m.debtCeiling
	if v == nil {
		return
	}
	return *v, true
}

// OldDebtCeiling returns the old "debtCeiling" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldDebtCeiling(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebtCeiling is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebtCeiling requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebtCeiling: %w", err)
	}
	return oldValue.DebtCeiling, nil
}

// ResetDebtCeiling resets all changes to the "debtCeiling" field.
func (m *PoolMutation) ResetDebtCeiling() {
	m.debtCeiling = nil
}

// SetLiquidationRatio sets the "liquidationRatio" field.
func (m *PoolMutation) SetLiquidationRatio(s string) {
	m.liquidationRatio = &s
}

// LiquidationRatio returns the value of the "liquidationRatio" field in the mutation.
func (m *PoolMutation) LiquidationRatio() (r string, exists bool) {
	v := m.liquidationRatio
	if v == nil {
		return
	}
	return *v, true
}

// OldLiquidationRatio returns the old "liquidationRatio" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldLiquidationRatio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLiquidationRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLiquidationRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiquidationRatio: %w", err)
	}
	return oldValue.LiquidationRatio, nil
}

// ResetLiquidationRatio resets all changes to the "liquidationRatio" field.
func (m *PoolMutation) ResetLiquidationRatio() {
	m.liquidationRatio = nil
}

// SetStabilityFeeRate sets the "stabilityFeeRate" field.
func (m *PoolMutation) SetStabilityFeeRate(s string) {
	m.stabilityFeeRate = &s
}

// StabilityFeeRate returns the value of the "stabilityFeeRate" field in the mutation.
func (m *PoolMutation) StabilityFeeRate() (r string, exists bool) {
	v := m.stabilityFeeRate
	if v == nil {
		return
	}
	return *v, true
}

// OldStabilityFeeRate returns the old "stabilityFeeRate" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldStabilityFeeRate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStabilityFeeRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStabilityFeeRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStabilityFeeRate: %w", err)
	}
	return oldValue.StabilityFeeRate, nil
}

// ResetStabilityFeeRate resets all changes to the "stabilityFeeRate" field.
func (m *PoolMutation) ResetStabilityFeeRate() {
	m.stabilityFeeRate = nil
}

// SetTokenAdapterAddress sets the "tokenAdapterAddress" field.
func (m *PoolMutation) SetTokenAdapterAddress(s string) {
	m.tokenAdapterAddress = &s
}

// TokenAdapterAddress returns the value of the "tokenAdapterAddress" field in the mutation.
func (m *PoolMutation) TokenAdapterAddress() (r string, exists bool) {
	v := m.tokenAdapterAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenAdapterAddress returns the old "tokenAdapterAddress" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldTokenAdapterAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenAdapterAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenAdapterAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenAdapterAddress: %w", err)
	}
	return oldValue.TokenAdapterAddress, nil
}

// ResetTokenAdapterAddress resets all changes to the "tokenAdapterAddress" field.
func (m *PoolMutation) ResetTokenAdapterAddress() {
	m.tokenAdapterAddress = nil
}

// SetLockedCollateral sets the "lockedCollateral" field.
func (m *PoolMutation) SetLockedCollateral(s string) {
	m.lockedCollateral = &s
}

// LockedCollateral returns the value of the "lockedCollateral" field in the mutation.
func (m *PoolMutation) LockedCollateral() (r string, exists bool) {
	v := m.lockedCollateral
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedCollateral returns the old "lockedCollateral" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldLockedCollateral(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedCollateral is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedCollateral requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedCollateral: %w", err)
	}
	return oldValue.LockedCollateral, nil
}

// ResetLockedCollateral resets all changes to the "lockedCollateral" field.
func (m *PoolMutation) ResetLockedCollateral() {
	m.lockedCollateral = nil
}

// SetCollateralPrice sets the "collateralPrice" field.
func (m *PoolMutation) SetCollateralPrice(s string) {
	m.collateralPrice = &s
}

// CollateralPrice returns the value of the "collateralPrice" field in the mutation.
func (m *PoolMutation) CollateralPrice() (r string, exists bool) {
	v := m.collateralPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldCollateralPrice returns the old "collateralPrice" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldCollateralPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollateralPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollateralPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollateralPrice: %w", err)
	}
	return oldValue.CollateralPrice, nil
}

// ResetCollateralPrice resets all changes to the "collateralPrice" field.
func (m *PoolMutation) ResetCollateralPrice() {
	m.collateralPrice = nil
}

// SetCollateralLastPrice sets the "collateralLastPrice" field.
func (m *PoolMutation) SetCollateralLastPrice(s string) {
	m.collateralLastPrice = &s
}

// CollateralLastPrice returns the value of the "collateralLastPrice" field in the mutation.
func (m *PoolMutation) CollateralLastPrice() (r string, exists bool) {
	v := m.collateralLastPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldCollateralLastPrice returns the old "collateralLastPrice" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldCollateralLastPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollateralLastPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollateralLastPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollateralLastPrice: %w", err)
	}
	return oldValue.CollateralLastPrice, nil
}

// ResetCollateralLastPrice resets all changes to the "collateralLastPrice" field.
func (m *PoolMutation) ResetCollateralLastPrice() {
	m.collateralLastPrice = nil
}

// SetPriceWithSafetyMargin sets the "priceWithSafetyMargin" field.
func (m *PoolMutation) SetPriceWithSafetyMargin(s string) {
	m.priceWithSafetyMargin = &s
}

// PriceWithSafetyMargin returns the value of the "priceWithSafetyMargin" field in the mutation.
func (m *PoolMutation) PriceWithSafetyMargin() (r string, exists bool) {
	v := m.priceWithSafetyMargin
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceWithSafetyMargin returns the old "priceWithSafetyMargin" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldPriceWithSafetyMargin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceWithSafetyMargin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceWithSafetyMargin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceWithSafetyMargin: %w", err)
	}
	return oldValue.PriceWithSafetyMargin, nil
}

// ResetPriceWithSafetyMargin resets all changes to the "priceWithSafetyMargin" field.
func (m *PoolMutation) ResetPriceWithSafetyMargin() {
	m.priceWithSafetyMargin = nil
}

// SetRawPrice sets the "rawPrice" field.
func (m *PoolMutation) SetRawPrice(s string) {
	m.rawPrice = &s
}

// RawPrice returns the value of the "rawPrice" field in the mutation.
func (m *PoolMutation) RawPrice() (r string, exists bool) {
	v := m.rawPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldRawPrice returns the old "rawPrice" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldRawPrice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRawPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRawPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRawPrice: %w", err)
	}
	return oldValue.RawPrice, nil
}

// ResetRawPrice resets all changes to the "rawPrice" field.
func (m *PoolMutation) ResetRawPrice() {
	m.rawPrice = nil
}

// SetDebtAccumulatedRate sets the "debtAccumulatedRate" field.
func (m *PoolMutation) SetDebtAccumulatedRate(s string) {
	m.debtAccumulatedRate = &s
}

// DebtAccumulatedRate returns the value of the "debtAccumulatedRate" field in the mutation.
func (m *PoolMutation) DebtAccumulatedRate() (r string, exists bool) {
	v := m.debtAccumulatedRate
	if v == nil {
		return
	}
	return *v, true
}

// OldDebtAccumulatedRate returns the old "debtAccumulatedRate" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldDebtAccumulatedRate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebtAccumulatedRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebtAccumulatedRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebtAccumulatedRate: %w", err)
	}
	return oldValue.DebtAccumulatedRate, nil
}

// ResetDebtAccumulatedRate resets all changes to the "debtAccumulatedRate" field.
func (m *PoolMutation) ResetDebtAccumulatedRate() {
	m.debtAccumulatedRate = nil
}

// SetTotalBorrowed sets the "totalBorrowed" field.
func (m *PoolMutation) SetTotalBorrowed(s string) {
	m.totalBorrowed = &s
}

// TotalBorrowed returns the value of the "totalBorrowed" field in the mutation.
func (m *PoolMutation) TotalBorrowed() (r string, exists bool) {
	v := m.totalBorrowed
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalBorrowed returns the old "totalBorrowed" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldTotalBorrowed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalBorrowed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalBorrowed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalBorrowed: %w", err)
	}
	return oldValue.TotalBorrowed, nil
}

// ResetTotalBorrowed resets all changes to the "totalBorrowed" field.
func (m *PoolMutation) ResetTotalBorrowed() {
	m.totalBorrowed = nil
}

// SetTotalAvailable sets the "totalAvailable" field.
func (m *PoolMutation) SetTotalAvailable(s string) {
	m.totalAvailable = &s
}

// TotalAvailable returns the value of the "totalAvailable" field in the mutation.
func (m *PoolMutation) TotalAvailable() (r string, exists bool) {
	v := m.totalAvailable
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalAvailable returns the old "totalAvailable" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldTotalAvailable(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalAvailable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalAvailable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalAvailable: %w", err)
	}
	return oldValue.TotalAvailable, nil
}

// ResetTotalAvailable resets all changes to the "totalAvailable" field.
func (m *PoolMutation) ResetTotalAvailable() {
	m.totalAvailable = nil
}

// SetTvl sets the "tvl" field.
func (m *PoolMutation) SetTvl(s string) {
	m.tvl = &s
}

// Tvl returns the value of the "tvl" field in the mutation.
func (m *PoolMutation) Tvl() (r string, exists bool) {
	v := m.tvl
	if v == nil {
		return
	}
	return *v, true
}

// OldTvl returns the old "tvl" field's value of the Pool entity.
// If the Pool object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PoolMutation) OldTvl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTvl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTvl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTvl: %w", err)
	}
	return oldValue.Tvl, nil
}

// ResetTvl resets all changes to the "tvl" field.
func (m *PoolMutation) ResetTvl() {
	m.tvl = nil
}

// AddPositionIDs adds the "positions" edge to the Position entity by ids.
func (m *PoolMutation) AddPositionIDs(ids ...string) {
	if m.positions == nil {
		m.positions = make(map[string]struct{})
	}
	for i := range ids {
		m.positions[ids[i]] = struct{}{}
	}
}

// ClearPositions clears the "positions" edge to the Position entity.
func (m *PoolMutation) ClearPositions() {
	m.clearedpositions = true
}

// PositionsCleared reports if the "positions" edge to the Position entity was cleared.
func (m *PoolMutation) PositionsCleared() bool {
	return m.clearedpositions
}

// RemovePositionIDs removes the "positions" edge to the Position entity by IDs.
func (m *PoolMutation) RemovePositionIDs(ids ...string) {
	if m.removedpositions == nil {
		m.removedpositions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.positions, ids[i])
		m.removedpositions[ids[i]] = struct{}{}
	}
}

// RemovedPositions returns the removed IDs of the "positions" edge to the Position entity.
func (m *PoolMutation) RemovedPositionsIDs() (ids []string) {
	for id := range m.removedpositions {
		ids = append(ids, id)
	}
	return
}

// PositionsIDs returns the "positions" edge IDs in the mutation.
func (m *PoolMutation) PositionsIDs() (ids []string) {
	for id := range m.positions {
		ids = append(ids, id)
	}
	return
}

// ResetPositions resets all changes to the "positions" edge.
func (m *PoolMutation) ResetPositions() {
	m.positions = nil
	m.clearedpositions = false
	m.removedpositions = nil
}

// Where appends a list predicates to the PoolMutation builder.
func (m *PoolMutation) Where(ps ...predicate.Pool) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PoolMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PoolMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pool, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PoolMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PoolMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pool).
func (m *PoolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PoolMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.poolName != nil {
		fields = append(fields, pool.FieldPoolName)
	}
	if m.debtCeiling != nil {
		fields = append(fields, pool.FieldDebtCeiling)
	}
	if m.liquidationRatio != nil {
		fields = append(fields, pool.FieldLiquidationRatio)
	}
	if m.stabilityFeeRate != nil {
		fields = append(fields, pool.FieldStabilityFeeRate)
	}
	if m.tokenAdapterAddress != nil {
		fields = append(fields, pool.FieldTokenAdapterAddress)
	}
	if m.lockedCollateral != nil {
		fields = append(fields, pool.FieldLockedCollateral)
	}
	if m.collateralPrice != nil {
		fields = append(fields, pool.FieldCollateralPrice)
	}
	if m.collateralLastPrice != nil {
		fields = append(fields, pool.FieldCollateralLastPrice)
	}
	if m.priceWithSafetyMargin != nil {
		fields = append(fields, pool.FieldPriceWithSafetyMargin)
	}
	if m.rawPrice != nil {
		fields = append(fields, pool.FieldRawPrice)
	}
	if m.debtAccumulatedRate != nil {
		fields = append(fields, pool.FieldDebtAccumulatedRate)
	}
	if m.totalBorrowed != nil {
		fields = append(fields, pool.FieldTotalBorrowed)
	}
	if m.totalAvailable != nil {
		fields = append(fields, pool.FieldTotalAvailable)
	}
	if m.tvl != nil {
		fields = append(fields, pool.FieldTvl)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PoolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pool.FieldPoolName:
		return m.PoolName()
	case pool.FieldDebtCeiling:
		return m.DebtCeiling()
	case pool.FieldLiquidationRatio:
		return m.LiquidationRatio()
	case pool.FieldStabilityFeeRate:
		return m.StabilityFeeRate()
	case pool.FieldTokenAdapterAddress:
		return m.TokenAdapterAddress()
	case pool.FieldLockedCollateral:
		return m.LockedCollateral()
	case pool.FieldCollateralPrice:
		return m.CollateralPrice()
	case pool.FieldCollateralLastPrice:
		return m.CollateralLastPrice()
	case pool.FieldPriceWithSafetyMargin:
		return m.PriceWithSafetyMargin()
	case pool.FieldRawPrice:
		return m.RawPrice()
	case pool.FieldDebtAccumulatedRate:
		return m.DebtAccumulatedRate()
	case pool.FieldTotalBorrowed:
		return m.TotalBorrowed()
	case pool.FieldTotalAvailable:
		return m.TotalAvailable()
	case pool.FieldTvl:
		return m.Tvl()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PoolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pool.FieldPoolName:
		return m.OldPoolName(ctx)
	case pool.FieldDebtCeiling:
		return m.OldDebtCeiling(ctx)
	case pool.FieldLiquidationRatio:
		return m.OldLiquidationRatio(ctx)
	case pool.FieldStabilityFeeRate:
		return m.OldStabilityFeeRate(ctx)
	case pool.FieldTokenAdapterAddress:
		return m.OldTokenAdapterAddress(ctx)
	case pool.FieldLockedCollateral:
		return m.OldLockedCollateral(ctx)
	case pool.FieldCollateralPrice:
		return m.OldCollateralPrice(ctx)
	case pool.FieldCollateralLastPrice:
		return m.OldCollateralLastPrice(ctx)
	case pool.FieldPriceWithSafetyMargin:
		return m.OldPriceWithSafetyMargin(ctx)
	case pool.FieldRawPrice:
		return m.OldRawPrice(ctx)
	case pool.FieldDebtAccumulatedRate:
		return m.OldDebtAccumulatedRate(ctx)
	case pool.FieldTotalBorrowed:
		return m.OldTotalBorrowed(ctx)
	case pool.FieldTotalAvailable:
		return m.OldTotalAvailable(ctx)
	case pool.FieldTvl:
		return m.OldTvl(ctx)
	}
	return nil, fmt.Errorf("unknown Pool field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pool.FieldPoolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoolName(v)
		return nil
	case pool.FieldDebtCeiling:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebtCeiling(v)
		return nil
	case pool.FieldLiquidationRatio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiquidationRatio(v)
		return nil
	case pool.FieldStabilityFeeRate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStabilityFeeRate(v)
		return nil
	case pool.FieldTokenAdapterAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenAdapterAddress(v)
		return nil
	case pool.FieldLockedCollateral:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedCollateral(v)
		return nil
	case pool.FieldCollateralPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollateralPrice(v)
		return nil
	case pool.FieldCollateralLastPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollateralLastPrice(v)
		return nil
	case pool.FieldPriceWithSafetyMargin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceWithSafetyMargin(v)
		return nil
	case pool.FieldRawPrice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRawPrice(v)
		return nil
	case pool.FieldDebtAccumulatedRate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebtAccumulatedRate(v)
		return nil
	case pool.FieldTotalBorrowed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalBorrowed(v)
		return nil
	case pool.FieldTotalAvailable:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalAvailable(v)
		return nil
	case pool.FieldTvl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTvl(v)
		return nil
	}
	return fmt.Errorf("unknown Pool field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PoolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PoolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PoolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PoolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PoolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PoolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pool nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PoolMutation) ResetField(name string) error {
	switch name {
	case pool.FieldPoolName:
		m.ResetPoolName()
		return nil
	case pool.FieldDebtCeiling:
		m.ResetDebtCeiling()
		return nil
	case pool.FieldLiquidationRatio:
		m.ResetLiquidationRatio()
		return nil
	case pool.FieldStabilityFeeRate:
		m.ResetStabilityFeeRate()
		return nil
	case pool.FieldTokenAdapterAddress:
		m.ResetTokenAdapterAddress()
		return nil
	case pool.FieldLockedCollateral:
		m.ResetLockedCollateral()
		return nil
	case pool.FieldCollateralPrice:
		m.ResetCollateralPrice()
		return nil
	case pool.FieldCollateralLastPrice:
		m.ResetCollateralLastPrice()
		return nil
	case pool.FieldPriceWithSafetyMargin:
		m.ResetPriceWithSafetyMargin()
		return nil
	case pool.FieldRawPrice:
		m.ResetRawPrice()
		return nil
	case pool.FieldDebtAccumulatedRate:
		m.ResetDebtAccumulatedRate()
		return nil
	case pool.FieldTotalBorrowed:
		m.ResetTotalBorrowed()
		return nil
	case pool.FieldTotalAvailable:
		m.ResetTotalAvailable()
		return nil
	case pool.FieldTvl:
		m.ResetTvl()
		return nil
	}
	return fmt.Errorf("unknown Pool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PoolMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.positions != nil {
		edges = append(edges, pool.EdgePositions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PoolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pool.EdgePositions:
		ids := make([]ent.Value, 0, len(m.positions))
		for id := range m.positions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PoolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpositions != nil {
		edges = append(edges, pool.EdgePositions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PoolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pool.EdgePositions:
		ids := make([]ent.Value, 0, len(m.removedpositions))
		for id := range m.removedpositions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PoolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpositions {
		edges = append(edges, pool.EdgePositions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PoolMutation) EdgeCleared(name string) bool {
	switch name {
	case pool.EdgePositions:
		return m.clearedpositions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PoolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Pool unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PoolMutation) ResetEdge(name string) error {
	switch name {
	case pool.EdgePositions:
		m.ResetPositions()
		return nil
	}
	return fmt.Errorf("unknown Pool edge %s", name)
}

// PositionMutation represents an operation that mutates the Position nodes in the graph.
type PositionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	positionAddress       *string
	userAddress           *string
	walletAddress         *string
	collateralPool        *string
	collateralPoolName    *string
	positionId            *string
	lockedCollateral      *string
	debtValue             *string
	debtShare             *string
	safetyBuffer          *string
	safetyBufferInPercent *string
	tvl                   *string
	positionStatus        *string
	liquidationCount      *string
	blockNumber           *string
	blockTimestamp        *string
	transaction           *string
	clearedFields         map[string]struct{}
	pool                  *string
	clearedpool           bool
	activity              map[string]struct{}
	removedactivity       map[string]struct{}
	clearedactivity       bool
	done                  bool
	oldValue              func(context.Context) (*Position, error)
	predicates            []predicate.Position
}

var _ ent.Mutation = (*PositionMutation)(nil)

// positionOption allows management of the mutation configuration using functional options.
type positionOption func(*PositionMutation)

// newPositionMutation creates new mutation for the Position entity.
func newPositionMutation(c config, op Op, opts ...positionOption) *PositionMutation {
	m := &PositionMutation{
		config:        c,
		op:            op,
		typ:           TypePosition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionID sets the ID field of the mutation.
func withPositionID(id string) positionOption {
	return func(m *PositionMutation) {
		var (
			err   error
			once  sync.Once
			value *Position
		)
		m.oldValue = func(ctx context.Context) (*Position, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Position.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPosition sets the old Position of the mutation.
func withPosition(node *Position) positionOption {
	return func(m *PositionMutation) {
		m.oldValue = func(context.Context) (*Position, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Position entities.
func (m *PositionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Position.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPositionAddress sets the "positionAddress" field.
func (m *PositionMutation) SetPositionAddress(s string) {
	m.positionAddress = &s
}

// PositionAddress returns the value of the "positionAddress" field in the mutation.
func (m *PositionMutation) PositionAddress() (r string, exists bool) {
	v := m.positionAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionAddress returns the old "positionAddress" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldPositionAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionAddress: %w", err)
	}
	return oldValue.PositionAddress, nil
}

// ResetPositionAddress resets all changes to the "positionAddress" field.
func (m *PositionMutation) ResetPositionAddress() {
	m.positionAddress = nil
}

// SetUserAddress sets the "userAddress" field.
func (m *PositionMutation) SetUserAddress(s string) {
	m.userAddress = &s
}

// UserAddress returns the value of the "userAddress" field in the mutation.
func (m *PositionMutation) UserAddress() (r string, exists bool) {
	v := m.userAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAddress returns the old "userAddress" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldUserAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAddress: %w", err)
	}
	return oldValue.UserAddress, nil
}

// ResetUserAddress resets all changes to the "userAddress" field.
func (m *PositionMutation) ResetUserAddress() {
	m.userAddress = nil
}

// SetWalletAddress sets the "walletAddress" field.
func (m *PositionMutation) SetWalletAddress(s string) {
	m.walletAddress = &s
}

// WalletAddress returns the value of the "walletAddress" field in the mutation.
func (m *PositionMutation) WalletAddress() (r string, exists bool) {
	v := m.walletAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletAddress returns the old "walletAddress" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldWalletAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWalletAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWalletAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletAddress: %w", err)
	}
	return oldValue.WalletAddress, nil
}

// ResetWalletAddress resets all changes to the "walletAddress" field.
func (m *PositionMutation) ResetWalletAddress() {
	m.walletAddress = nil
}

// SetCollateralPool sets the "collateralPool" field.
func (m *PositionMutation) SetCollateralPool(s string) {
	m.collateralPool = &s
}

// CollateralPool returns the value of the "collateralPool" field in the mutation.
func (m *PositionMutation) CollateralPool() (r string, exists bool) {
	v := m.collateralPool
	if v == nil {
		return
	}
	return *v, true
}

// OldCollateralPool returns the old "collateralPool" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCollateralPool(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollateralPool is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollateralPool requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollateralPool: %w", err)
	}
	return oldValue.CollateralPool, nil
}

// ResetCollateralPool resets all changes to the "collateralPool" field.
func (m *PositionMutation) ResetCollateralPool() {
	m.collateralPool = nil
}

// SetCollateralPoolName sets the "collateralPoolName" field.
func (m *PositionMutation) SetCollateralPoolName(s string) {
	m.collateralPoolName = &s
}

// CollateralPoolName returns the value of the "collateralPoolName" field in the mutation.
func (m *PositionMutation) CollateralPoolName() (r string, exists bool) {
	v := m.collateralPoolName
	if v == nil {
		return
	}
	return *v, true
}

// OldCollateralPoolName returns the old "collateralPoolName" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldCollateralPoolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollateralPoolName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollateralPoolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollateralPoolName: %w", err)
	}
	return oldValue.CollateralPoolName, nil
}

// ResetCollateralPoolName resets all changes to the "collateralPoolName" field.
func (m *PositionMutation) ResetCollateralPoolName() {
	m.collateralPoolName = nil
}

// SetPositionId sets the "positionId" field.
func (m *PositionMutation) SetPositionId(s string) {
	m.positionId = &s
}

// PositionId returns the value of the "positionId" field in the mutation.
func (m *PositionMutation) PositionId() (r string, exists bool) {
	v := m.positionId
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionId returns the old "positionId" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldPositionId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionId: %w", err)
	}
	return oldValue.PositionId, nil
}

// ResetPositionId resets all changes to the "positionId" field.
func (m *PositionMutation) ResetPositionId() {
	m.positionId = nil
}

// SetLockedCollateral sets the "lockedCollateral" field.
func (m *PositionMutation) SetLockedCollateral(s string) {
	m.lockedCollateral = &s
}

// LockedCollateral returns the value of the "lockedCollateral" field in the mutation.
func (m *PositionMutation) LockedCollateral() (r string, exists bool) {
	v := m.lockedCollateral
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedCollateral returns the old "lockedCollateral" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldLockedCollateral(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedCollateral is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedCollateral requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedCollateral: %w", err)
	}
	return oldValue.LockedCollateral, nil
}

// ResetLockedCollateral resets all changes to the "lockedCollateral" field.
func (m *PositionMutation) ResetLockedCollateral() {
	m.lockedCollateral = nil
}

// SetDebtValue sets the "debtValue" field.
func (m *PositionMutation) SetDebtValue(s string) {
	m.debtValue = &s
}

// DebtValue returns the value of the "debtValue" field in the mutation.
func (m *PositionMutation) DebtValue() (r string, exists bool) {
	v := m.debtValue
	if v == nil {
		return
	}
	return *v, true
}

// OldDebtValue returns the old "debtValue" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDebtValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebtValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebtValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebtValue: %w", err)
	}
	return oldValue.DebtValue, nil
}

// ResetDebtValue resets all changes to the "debtValue" field.
func (m *PositionMutation) ResetDebtValue() {
	m.debtValue = nil
}

// SetDebtShare sets the "debtShare" field.
func (m *PositionMutation) SetDebtShare(s string) {
	m.debtShare = &s
}

// DebtShare returns the value of the "debtShare" field in the mutation.
func (m *PositionMutation) DebtShare() (r string, exists bool) {
	v := m.debtShare
	if v == nil {
		return
	}
	return *v, true
}

// OldDebtShare returns the old "debtShare" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldDebtShare(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebtShare is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebtShare requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebtShare: %w", err)
	}
	return oldValue.DebtShare, nil
}

// ResetDebtShare resets all changes to the "debtShare" field.
func (m *PositionMutation) ResetDebtShare() {
	m.debtShare = nil
}

// SetSafetyBuffer sets the "safetyBuffer" field.
func (m *PositionMutation) SetSafetyBuffer(s string) {
	m.safetyBuffer = &s
}

// SafetyBuffer returns the value of the "safetyBuffer" field in the mutation.
func (m *PositionMutation) SafetyBuffer() (r string, exists bool) {
	v := m.safetyBuffer
	if v == nil {
		return
	}
	return *v, true
}

// OldSafetyBuffer returns the old "safetyBuffer" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldSafetyBuffer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSafetyBuffer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSafetyBuffer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSafetyBuffer: %w", err)
	}
	return oldValue.SafetyBuffer, nil
}

// ResetSafetyBuffer resets all changes to the "safetyBuffer" field.
func (m *PositionMutation) ResetSafetyBuffer() {
	m.safetyBuffer = nil
}

// SetSafetyBufferInPercent sets the "safetyBufferInPercent" field.
func (m *PositionMutation) SetSafetyBufferInPercent(s string) {
	m.safetyBufferInPercent = &s
}

// SafetyBufferInPercent returns the value of the "safetyBufferInPercent" field in the mutation.
func (m *PositionMutation) SafetyBufferInPercent() (r string, exists bool) {
	v := m.safetyBufferInPercent
	if v == nil {
		return
	}
	return *v, true
}

// OldSafetyBufferInPercent returns the old "safetyBufferInPercent" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldSafetyBufferInPercent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSafetyBufferInPercent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSafetyBufferInPercent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSafetyBufferInPercent: %w", err)
	}
	return oldValue.SafetyBufferInPercent, nil
}

// ResetSafetyBufferInPercent resets all changes to the "safetyBufferInPercent" field.
func (m *PositionMutation) ResetSafetyBufferInPercent() {
	m.safetyBufferInPercent = nil
}

// SetTvl sets the "tvl" field.
func (m *PositionMutation) SetTvl(s string) {
	m.tvl = &s
}

// Tvl returns the value of the "tvl" field in the mutation.
func (m *PositionMutation) Tvl() (r string, exists bool) {
	v := m.tvl
	if v == nil {
		return
	}
	return *v, true
}

// OldTvl returns the old "tvl" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldTvl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTvl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTvl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTvl: %w", err)
	}
	return oldValue.Tvl, nil
}

// ResetTvl resets all changes to the "tvl" field.
func (m *PositionMutation) ResetTvl() {
	m.tvl = nil
}

// SetPositionStatus sets the "positionStatus" field.
func (m *PositionMutation) SetPositionStatus(s string) {
	m.positionStatus = &s
}

// PositionStatus returns the value of the "positionStatus" field in the mutation.
func (m *PositionMutation) PositionStatus() (r string, exists bool) {
	v := m.positionStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldPositionStatus returns the old "positionStatus" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldPositionStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPositionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPositionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPositionStatus: %w", err)
	}
	return oldValue.PositionStatus, nil
}

// ResetPositionStatus resets all changes to the "positionStatus" field.
func (m *PositionMutation) ResetPositionStatus() {
	m.positionStatus = nil
}

// SetLiquidationCount sets the "liquidationCount" field.
func (m *PositionMutation) SetLiquidationCount(s string) {
	m.liquidationCount = &s
}

// LiquidationCount returns the value of the "liquidationCount" field in the mutation.
func (m *PositionMutation) LiquidationCount() (r string, exists bool) {
	v := m.liquidationCount
	if v == nil {
		return
	}
	return *v, true
}

// OldLiquidationCount returns the old "liquidationCount" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldLiquidationCount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLiquidationCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLiquidationCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiquidationCount: %w", err)
	}
	return oldValue.LiquidationCount, nil
}

// ResetLiquidationCount resets all changes to the "liquidationCount" field.
func (m *PositionMutation) ResetLiquidationCount() {
	m.liquidationCount = nil
}

// SetBlockNumber sets the "blockNumber" field.
func (m *PositionMutation) SetBlockNumber(s string) {
	m.blockNumber = &s
}

// BlockNumber returns the value of the "blockNumber" field in the mutation.
func (m *PositionMutation) BlockNumber() (r string, exists bool) {
	v := m.blockNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "blockNumber" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldBlockNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// ResetBlockNumber resets all changes to the "blockNumber" field.
func (m *PositionMutation) ResetBlockNumber() {
	m.blockNumber = nil
}

// SetBlockTimestamp sets the "blockTimestamp" field.
func (m *PositionMutation) SetBlockTimestamp(s string) {
	m.blockTimestamp = &s
}

// BlockTimestamp returns the value of the "blockTimestamp" field in the mutation.
func (m *PositionMutation) BlockTimestamp() (r string, exists bool) {
	v := m.blockTimestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockTimestamp returns the old "blockTimestamp" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldBlockTimestamp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockTimestamp: %w", err)
	}
	return oldValue.BlockTimestamp, nil
}

// ResetBlockTimestamp resets all changes to the "blockTimestamp" field.
func (m *PositionMutation) ResetBlockTimestamp() {
	m.blockTimestamp = nil
}

// SetTransaction sets the "transaction" field.
func (m *PositionMutation) SetTransaction(s string) {
	m.transaction = &s
}

// Transaction returns the value of the "transaction" field in the mutation.
func (m *PositionMutation) Transaction() (r string, exists bool) {
	v := m.transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTransaction returns the old "transaction" field's value of the Position entity.
// If the Position object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionMutation) OldTransaction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransaction: %w", err)
	}
	return oldValue.Transaction, nil
}

// ResetTransaction resets all changes to the "transaction" field.
func (m *PositionMutation) ResetTransaction() {
	m.transaction = nil
}

// SetPoolID sets the "pool" edge to the Pool entity by id.
func (m *PositionMutation) SetPoolID(id string) {
	m.pool = &id
}

// ClearPool clears the "pool" edge to the Pool entity.
func (m *PositionMutation) ClearPool() {
	m.clearedpool = true
}

// PoolCleared reports if the "pool" edge to the Pool entity was cleared.
func (m *PositionMutation) PoolCleared() bool {
	return m.clearedpool
}

// PoolID returns the "pool" edge ID in the mutation.
func (m *PositionMutation) PoolID() (id string, exists bool) {
	if m.pool != nil {
		return *m.pool, true
	}
	return
}

// PoolIDs returns the "pool" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PoolID instead. It exists only for internal usage by the builders.
func (m *PositionMutation) PoolIDs() (ids []string) {
	if id := m.pool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPool resets all changes to the "pool" edge.
func (m *PositionMutation) ResetPool() {
	m.pool = nil
	m.clearedpool = false
}

// AddActivityIDs adds the "activity" edge to the PositionActivity entity by ids.
func (m *PositionMutation) AddActivityIDs(ids ...string) {
	if m.activity == nil {
		m.activity = make(map[string]struct{})
	}
	for i := range ids {
		m.activity[ids[i]] = struct{}{}
	}
}

// ClearActivity clears the "activity" edge to the PositionActivity entity.
func (m *PositionMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the PositionActivity entity was cleared.
func (m *PositionMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// RemoveActivityIDs removes the "activity" edge to the PositionActivity entity by IDs.
func (m *PositionMutation) RemoveActivityIDs(ids ...string) {
	if m.removedactivity == nil {
		m.removedactivity = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activity, ids[i])
		m.removedactivity[ids[i]] = struct{}{}
	}
}

// RemovedActivity returns the removed IDs of the "activity" edge to the PositionActivity entity.
func (m *PositionMutation) RemovedActivityIDs() (ids []string) {
	for id := range m.removedactivity {
		ids = append(ids, id)
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
func (m *PositionMutation) ActivityIDs() (ids []string) {
	for id := range m.activity {
		ids = append(ids, id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *PositionMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
	m.removedactivity = nil
}

// Where appends a list predicates to the PositionMutation builder.
func (m *PositionMutation) Where(ps ...predicate.Position) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Position, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Position).
func (m *PositionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.positionAddress != nil {
		fields = append(fields, position.FieldPositionAddress)
	}
	if m.userAddress != nil {
		fields = append(fields, position.FieldUserAddress)
	}
	if m.walletAddress != nil {
		fields = append(fields, position.FieldWalletAddress)
	}
	if m.collateralPool != nil {
		fields = append(fields, position.FieldCollateralPool)
	}
	if m.collateralPoolName != nil {
		fields = append(fields, position.FieldCollateralPoolName)
	}
	if m.positionId != nil {
		fields = append(fields, position.FieldPositionId)
	}
	if m.lockedCollateral != nil {
		fields = append(fields, position.FieldLockedCollateral)
	}
	if m.debtValue != nil {
		fields = append(fields, position.FieldDebtValue)
	}
	if m.debtShare != nil {
		fields = append(fields, position.FieldDebtShare)
	}
	if m.safetyBuffer != nil {
		fields = append(fields, position.FieldSafetyBuffer)
	}
	if m.safetyBufferInPercent != nil {
		fields = append(fields, position.FieldSafetyBufferInPercent)
	}
	if m.tvl != nil {
		fields = append(fields, position.FieldTvl)
	}
	if m.positionStatus != nil {
		fields = append(fields, position.FieldPositionStatus)
	}
	if m.liquidationCount != nil {
		fields = append(fields, position.FieldLiquidationCount)
	}
	if m.blockNumber != nil {
		fields = append(fields, position.FieldBlockNumber)
	}
	if m.blockTimestamp != nil {
		fields = append(fields, position.FieldBlockTimestamp)
	}
	if m.transaction != nil {
		fields = append(fields, position.FieldTransaction)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case position.FieldPositionAddress:
		return m.PositionAddress()
	case position.FieldUserAddress:
		return m.UserAddress()
	case position.FieldWalletAddress:
		return m.WalletAddress()
	case position.FieldCollateralPool:
		return m.CollateralPool()
	case position.FieldCollateralPoolName:
		return m.CollateralPoolName()
	case position.FieldPositionId:
		return m.PositionId()
	case position.FieldLockedCollateral:
		return m.LockedCollateral()
	case position.FieldDebtValue:
		return m.DebtValue()
	case position.FieldDebtShare:
		return m.DebtShare()
	case position.FieldSafetyBuffer:
		return m.SafetyBuffer()
	case position.FieldSafetyBufferInPercent:
		return m.SafetyBufferInPercent()
	case position.FieldTvl:
		return m.Tvl()
	case position.FieldPositionStatus:
		return m.PositionStatus()
	case position.FieldLiquidationCount:
		return m.LiquidationCount()
	case position.FieldBlockNumber:
		return m.BlockNumber()
	case position.FieldBlockTimestamp:
		return m.BlockTimestamp()
	case position.FieldTransaction:
		return m.Transaction()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case position.FieldPositionAddress:
		return m.OldPositionAddress(ctx)
	case position.FieldUserAddress:
		return m.OldUserAddress(ctx)
	case position.FieldWalletAddress:
		return m.OldWalletAddress(ctx)
	case position.FieldCollateralPool:
		return m.OldCollateralPool(ctx)
	case position.FieldCollateralPoolName:
		return m.OldCollateralPoolName(ctx)
	case position.FieldPositionId:
		return m.OldPositionId(ctx)
	case position.FieldLockedCollateral:
		return m.OldLockedCollateral(ctx)
	case position.FieldDebtValue:
		return m.OldDebtValue(ctx)
	case position.FieldDebtShare:
		return m.OldDebtShare(ctx)
	case position.FieldSafetyBuffer:
		return m.OldSafetyBuffer(ctx)
	case position.FieldSafetyBufferInPercent:
		return m.OldSafetyBufferInPercent(ctx)
	case position.FieldTvl:
		return m.OldTvl(ctx)
	case position.FieldPositionStatus:
		return m.OldPositionStatus(ctx)
	case position.FieldLiquidationCount:
		return m.OldLiquidationCount(ctx)
	case position.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case position.FieldBlockTimestamp:
		return m.OldBlockTimestamp(ctx)
	case position.FieldTransaction:
		return m.OldTransaction(ctx)
	}
	return nil, fmt.Errorf("unknown Position field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case position.FieldPositionAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionAddress(v)
		return nil
	case position.FieldUserAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAddress(v)
		return nil
	case position.FieldWalletAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletAddress(v)
		return nil
	case position.FieldCollateralPool:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollateralPool(v)
		return nil
	case position.FieldCollateralPoolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollateralPoolName(v)
		return nil
	case position.FieldPositionId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionId(v)
		return nil
	case position.FieldLockedCollateral:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedCollateral(v)
		return nil
	case position.FieldDebtValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebtValue(v)
		return nil
	case position.FieldDebtShare:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebtShare(v)
		return nil
	case position.FieldSafetyBuffer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSafetyBuffer(v)
		return nil
	case position.FieldSafetyBufferInPercent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSafetyBufferInPercent(v)
		return nil
	case position.FieldTvl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTvl(v)
		return nil
	case position.FieldPositionStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPositionStatus(v)
		return nil
	case position.FieldLiquidationCount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiquidationCount(v)
		return nil
	case position.FieldBlockNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case position.FieldBlockTimestamp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockTimestamp(v)
		return nil
	case position.FieldTransaction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransaction(v)
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Position numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Position nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionMutation) ResetField(name string) error {
	switch name {
	case position.FieldPositionAddress:
		m.ResetPositionAddress()
		return nil
	case position.FieldUserAddress:
		m.ResetUserAddress()
		return nil
	case position.FieldWalletAddress:
		m.ResetWalletAddress()
		return nil
	case position.FieldCollateralPool:
		m.ResetCollateralPool()
		return nil
	case position.FieldCollateralPoolName:
		m.ResetCollateralPoolName()
		return nil
	case position.FieldPositionId:
		m.ResetPositionId()
		return nil
	case position.FieldLockedCollateral:
		m.ResetLockedCollateral()
		return nil
	case position.FieldDebtValue:
		m.ResetDebtValue()
		return nil
	case position.FieldDebtShare:
		m.ResetDebtShare()
		return nil
	case position.FieldSafetyBuffer:
		m.ResetSafetyBuffer()
		return nil
	case position.FieldSafetyBufferInPercent:
		m.ResetSafetyBufferInPercent()
		return nil
	case position.FieldTvl:
		m.ResetTvl()
		return nil
	case position.FieldPositionStatus:
		m.ResetPositionStatus()
		return nil
	case position.FieldLiquidationCount:
		m.ResetLiquidationCount()
		return nil
	case position.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case position.FieldBlockTimestamp:
		m.ResetBlockTimestamp()
		return nil
	case position.FieldTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown Position field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.pool != nil {
		edges = append(edges, position.EdgePool)
	}
	if m.activity != nil {
		edges = append(edges, position.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case position.EdgePool:
		if id := m.pool; id != nil {
			return []ent.Value{*id}
		}
	case position.EdgeActivity:
		ids := make([]ent.Value, 0, len(m.activity))
		for id := range m.activity {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedactivity != nil {
		edges = append(edges, position.EdgeActivity)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case position.EdgeActivity:
		ids := make([]ent.Value, 0, len(m.removedactivity))
		for id := range m.removedactivity {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpool {
		edges = append(edges, position.EdgePool)
	}
	if m.clearedactivity {
		edges = append(edges, position.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionMutation) EdgeCleared(name string) bool {
	switch name {
	case position.EdgePool:
		return m.clearedpool
	case position.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionMutation) ClearEdge(name string) error {
	switch name {
	case position.EdgePool:
		m.ClearPool()
		return nil
	}
	return fmt.Errorf("unknown Position unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionMutation) ResetEdge(name string) error {
	switch name {
	case position.EdgePool:
		m.ResetPool()
		return nil
	case position.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown Position edge %s", name)
}

// PositionActivityMutation represents an operation that mutates the PositionActivity nodes in the graph.
type PositionActivityMutation struct {
	config
	op               Op
	typ              string
	id               *string
	activityState    *string
	collateralAmount *string
	debtAmount       *string
	blockNumber      *string
	blockTimestamp   *string
	transaction      *string
	clearedFields    map[string]struct{}
	position         *string
	clearedposition  bool
	done             bool
	oldValue         func(context.Context) (*PositionActivity, error)
	predicates       []predicate.PositionActivity
}

var _ ent.Mutation = (*PositionActivityMutation)(nil)

// positionactivityOption allows management of the mutation configuration using functional options.
type positionactivityOption func(*PositionActivityMutation)

// newPositionActivityMutation creates new mutation for the PositionActivity entity.
func newPositionActivityMutation(c config, op Op, opts ...positionactivityOption) *PositionActivityMutation {
	m := &PositionActivityMutation{
		config:        c,
		op:            op,
		typ:           TypePositionActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPositionActivityID sets the ID field of the mutation.
func withPositionActivityID(id string) positionactivityOption {
	return func(m *PositionActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *PositionActivity
		)
		m.oldValue = func(ctx context.Context) (*PositionActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PositionActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPositionActivity sets the old PositionActivity of the mutation.
func withPositionActivity(node *PositionActivity) positionactivityOption {
	return func(m *PositionActivityMutation) {
		m.oldValue = func(context.Context) (*PositionActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PositionActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PositionActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PositionActivity entities.
func (m *PositionActivityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PositionActivityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PositionActivityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PositionActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetActivityState sets the "activityState" field.
func (m *PositionActivityMutation) SetActivityState(s string) {
	m.activityState = &s
}

// ActivityState returns the value of the "activityState" field in the mutation.
func (m *PositionActivityMutation) ActivityState() (r string, exists bool) {
	v := m.activityState
	if v == nil {
		return
	}
	return *v, true
}

// OldActivityState returns the old "activityState" field's value of the PositionActivity entity.
// If the PositionActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionActivityMutation) OldActivityState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivityState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivityState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivityState: %w", err)
	}
	return oldValue.ActivityState, nil
}

// ResetActivityState resets all changes to the "activityState" field.
func (m *PositionActivityMutation) ResetActivityState() {
	m.activityState = nil
}

// SetCollateralAmount sets the "collateralAmount" field.
func (m *PositionActivityMutation) SetCollateralAmount(s string) {
	m.collateralAmount = &s
}

// CollateralAmount returns the value of the "collateralAmount" field in the mutation.
func (m *PositionActivityMutation) CollateralAmount() (r string, exists bool) {
	v := m.collateralAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldCollateralAmount returns the old "collateralAmount" field's value of the PositionActivity entity.
// If the PositionActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionActivityMutation) OldCollateralAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCollateralAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCollateralAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCollateralAmount: %w", err)
	}
	return oldValue.CollateralAmount, nil
}

// ResetCollateralAmount resets all changes to the "collateralAmount" field.
func (m *PositionActivityMutation) ResetCollateralAmount() {
	m.collateralAmount = nil
}

// SetDebtAmount sets the "debtAmount" field.
func (m *PositionActivityMutation) SetDebtAmount(s string) {
	m.debtAmount = &s
}

// DebtAmount returns the value of the "debtAmount" field in the mutation.
func (m *PositionActivityMutation) DebtAmount() (r string, exists bool) {
	v := m.debtAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldDebtAmount returns the old "debtAmount" field's value of the PositionActivity entity.
// If the PositionActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionActivityMutation) OldDebtAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDebtAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDebtAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDebtAmount: %w", err)
	}
	return oldValue.DebtAmount, nil
}

// ResetDebtAmount resets all changes to the "debtAmount" field.
func (m *PositionActivityMutation) ResetDebtAmount() {
	m.debtAmount = nil
}

// SetBlockNumber sets the "blockNumber" field.
func (m *PositionActivityMutation) SetBlockNumber(s string) {
	m.blockNumber = &s
}

// BlockNumber returns the value of the "blockNumber" field in the mutation.
func (m *PositionActivityMutation) BlockNumber() (r string, exists bool) {
	v := m.blockNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "blockNumber" field's value of the PositionActivity entity.
// If the PositionActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionActivityMutation) OldBlockNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// ResetBlockNumber resets all changes to the "blockNumber" field.
func (m *PositionActivityMutation) ResetBlockNumber() {
	m.blockNumber = nil
}

// SetBlockTimestamp sets the "blockTimestamp" field.
func (m *PositionActivityMutation) SetBlockTimestamp(s string) {
	m.blockTimestamp = &s
}

// BlockTimestamp returns the value of the "blockTimestamp" field in the mutation.
func (m *PositionActivityMutation) BlockTimestamp() (r string, exists bool) {
	v := m.blockTimestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockTimestamp returns the old "blockTimestamp" field's value of the PositionActivity entity.
// If the PositionActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionActivityMutation) OldBlockTimestamp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockTimestamp: %w", err)
	}
	return oldValue.BlockTimestamp, nil
}

// ResetBlockTimestamp resets all changes to the "blockTimestamp" field.
func (m *PositionActivityMutation) ResetBlockTimestamp() {
	m.blockTimestamp = nil
}

// SetTransaction sets the "transaction" field.
func (m *PositionActivityMutation) SetTransaction(s string) {
	m.transaction = &s
}

// Transaction returns the value of the "transaction" field in the mutation.
func (m *PositionActivityMutation) Transaction() (r string, exists bool) {
	v := m.transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTransaction returns the old "transaction" field's value of the PositionActivity entity.
// If the PositionActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PositionActivityMutation) OldTransaction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransaction: %w", err)
	}
	return oldValue.Transaction, nil
}

// ResetTransaction resets all changes to the "transaction" field.
func (m *PositionActivityMutation) ResetTransaction() {
	m.transaction = nil
}

// SetPositionID sets the "position" edge to the Position entity by id.
func (m *PositionActivityMutation) SetPositionID(id string) {
	m.position = &id
}

// ClearPosition clears the "position" edge to the Position entity.
func (m *PositionActivityMutation) ClearPosition() {
	m.clearedposition = true
}

// PositionCleared reports if the "position" edge to the Position entity was cleared.
func (m *PositionActivityMutation) PositionCleared() bool {
	return m.clearedposition
}

// PositionID returns the "position" edge ID in the mutation.
func (m *PositionActivityMutation) PositionID() (id string, exists bool) {
	if m.position != nil {
		return *m.position, true
	}
	return
}

// PositionIDs returns the "position" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PositionID instead. It exists only for internal usage by the builders.
func (m *PositionActivityMutation) PositionIDs() (ids []string) {
	if id := m.position; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPosition resets all changes to the "position" edge.
func (m *PositionActivityMutation) ResetPosition() {
	m.position = nil
	m.clearedposition = false
}

// Where appends a list predicates to the PositionActivityMutation builder.
func (m *PositionActivityMutation) Where(ps ...predicate.PositionActivity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PositionActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PositionActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PositionActivity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PositionActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PositionActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PositionActivity).
func (m *PositionActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PositionActivityMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.activityState != nil {
		fields = append(fields, positionactivity.FieldActivityState)
	}
	if m.collateralAmount != nil {
		fields = append(fields, positionactivity.FieldCollateralAmount)
	}
	if m.debtAmount != nil {
		fields = append(fields, positionactivity.FieldDebtAmount)
	}
	if m.blockNumber != nil {
		fields = append(fields, positionactivity.FieldBlockNumber)
	}
	if m.blockTimestamp != nil {
		fields = append(fields, positionactivity.FieldBlockTimestamp)
	}
	if m.transaction != nil {
		fields = append(fields, positionactivity.FieldTransaction)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PositionActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case positionactivity.FieldActivityState:
		return m.ActivityState()
	case positionactivity.FieldCollateralAmount:
		return m.CollateralAmount()
	case positionactivity.FieldDebtAmount:
		return m.DebtAmount()
	case positionactivity.FieldBlockNumber:
		return m.BlockNumber()
	case positionactivity.FieldBlockTimestamp:
		return m.BlockTimestamp()
	case positionactivity.FieldTransaction:
		return m.Transaction()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PositionActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case positionactivity.FieldActivityState:
		return m.OldActivityState(ctx)
	case positionactivity.FieldCollateralAmount:
		return m.OldCollateralAmount(ctx)
	case positionactivity.FieldDebtAmount:
		return m.OldDebtAmount(ctx)
	case positionactivity.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case positionactivity.FieldBlockTimestamp:
		return m.OldBlockTimestamp(ctx)
	case positionactivity.FieldTransaction:
		return m.OldTransaction(ctx)
	}
	return nil, fmt.Errorf("unknown PositionActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case positionactivity.FieldActivityState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivityState(v)
		return nil
	case positionactivity.FieldCollateralAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCollateralAmount(v)
		return nil
	case positionactivity.FieldDebtAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDebtAmount(v)
		return nil
	case positionactivity.FieldBlockNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case positionactivity.FieldBlockTimestamp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockTimestamp(v)
		return nil
	case positionactivity.FieldTransaction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransaction(v)
		return nil
	}
	return fmt.Errorf("unknown PositionActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PositionActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PositionActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PositionActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PositionActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PositionActivityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PositionActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PositionActivityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PositionActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PositionActivityMutation) ResetField(name string) error {
	switch name {
	case positionactivity.FieldActivityState:
		m.ResetActivityState()
		return nil
	case positionactivity.FieldCollateralAmount:
		m.ResetCollateralAmount()
		return nil
	case positionactivity.FieldDebtAmount:
		m.ResetDebtAmount()
		return nil
	case positionactivity.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case positionactivity.FieldBlockTimestamp:
		m.ResetBlockTimestamp()
		return nil
	case positionactivity.FieldTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown PositionActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PositionActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.position != nil {
		edges = append(edges, positionactivity.EdgePosition)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PositionActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case positionactivity.EdgePosition:
		if id := m.position; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PositionActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PositionActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PositionActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedposition {
		edges = append(edges, positionactivity.EdgePosition)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PositionActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case positionactivity.EdgePosition:
		return m.clearedposition
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PositionActivityMutation) ClearEdge(name string) error {
	switch name {
	case positionactivity.EdgePosition:
		m.ClearPosition()
		return nil
	}
	return fmt.Errorf("unknown PositionActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PositionActivityMutation) ResetEdge(name string) error {
	switch name {
	case positionactivity.EdgePosition:
		m.ResetPosition()
		return nil
	}
	return fmt.Errorf("unknown PositionActivity edge %s", name)
}

// ProtocolStatMutation represents an operation that mutates the ProtocolStat nodes in the graph.
type ProtocolStatMutation struct {
	config
	op            Op
	typ           string
	id            *string
	totalSupply   *string
	tvl           *string
	pools         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ProtocolStat, error)
	predicates    []predicate.ProtocolStat
}

var _ ent.Mutation = (*ProtocolStatMutation)(nil)

// protocolstatOption allows management of the mutation configuration using functional options.
type protocolstatOption func(*ProtocolStatMutation)

// newProtocolStatMutation creates new mutation for the ProtocolStat entity.
func newProtocolStatMutation(c config, op Op, opts ...protocolstatOption) *ProtocolStatMutation {
	m := &ProtocolStatMutation{
		config:        c,
		op:            op,
		typ:           TypeProtocolStat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProtocolStatID sets the ID field of the mutation.
func withProtocolStatID(id string) protocolstatOption {
	return func(m *ProtocolStatMutation) {
		var (
			err   error
			once  sync.Once
			value *ProtocolStat
		)
		m.oldValue = func(ctx context.Context) (*ProtocolStat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProtocolStat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProtocolStat sets the old ProtocolStat of the mutation.
func withProtocolStat(node *ProtocolStat) protocolstatOption {
	return func(m *ProtocolStatMutation) {
		m.oldValue = func(context.Context) (*ProtocolStat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProtocolStatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProtocolStatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProtocolStat entities.
func (m *ProtocolStatMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProtocolStatMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProtocolStatMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProtocolStat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTotalSupply sets the "totalSupply" field.
func (m *ProtocolStatMutation) SetTotalSupply(s string) {
	m.totalSupply = &s
}

// TotalSupply returns the value of the "totalSupply" field in the mutation.
func (m *ProtocolStatMutation) TotalSupply() (r string, exists bool) {
	v := m.totalSupply
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSupply returns the old "totalSupply" field's value of the ProtocolStat entity.
// If the ProtocolStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtocolStatMutation) OldTotalSupply(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSupply is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSupply requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSupply: %w", err)
	}
	return oldValue.TotalSupply, nil
}

// ResetTotalSupply resets all changes to the "totalSupply" field.
func (m *ProtocolStatMutation) ResetTotalSupply() {
	m.totalSupply = nil
}

// SetTvl sets the "tvl" field.
func (m *ProtocolStatMutation) SetTvl(s string) {
	m.tvl = &s
}

// Tvl returns the value of the "tvl" field in the mutation.
func (m *ProtocolStatMutation) Tvl() (r string, exists bool) {
	v := m.tvl
	if v == nil {
		return
	}
	return *v, true
}

// OldTvl returns the old "tvl" field's value of the ProtocolStat entity.
// If the ProtocolStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtocolStatMutation) OldTvl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTvl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTvl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTvl: %w", err)
	}
	return oldValue.Tvl, nil
}

// ResetTvl resets all changes to the "tvl" field.
func (m *ProtocolStatMutation) ResetTvl() {
	m.tvl = nil
}

// SetPools sets the "pools" field.
func (m *ProtocolStatMutation) SetPools(s string) {
	m.pools = &s
}

// Pools returns the value of the "pools" field in the mutation.
func (m *ProtocolStatMutation) Pools() (r string, exists bool) {
	v := m.pools
	if v == nil {
		return
	}
	return *v, true
}

// OldPools returns the old "pools" field's value of the ProtocolStat entity.
// If the ProtocolStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProtocolStatMutation) OldPools(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPools is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPools requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPools: %w", err)
	}
	return oldValue.Pools, nil
}

// ResetPools resets all changes to the "pools" field.
func (m *ProtocolStatMutation) ResetPools() {
	m.pools = nil
}

// Where appends a list predicates to the ProtocolStatMutation builder.
func (m *ProtocolStatMutation) Where(ps ...predicate.ProtocolStat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProtocolStatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProtocolStatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProtocolStat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProtocolStatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProtocolStatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProtocolStat).
func (m *ProtocolStatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProtocolStatMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.totalSupply != nil {
		fields = append(fields, protocolstat.FieldTotalSupply)
	}
	if m.tvl != nil {
		fields = append(fields, protocolstat.FieldTvl)
	}
	if m.pools != nil {
		fields = append(fields, protocolstat.FieldPools)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProtocolStatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case protocolstat.FieldTotalSupply:
		return m.TotalSupply()
	case protocolstat.FieldTvl:
		return m.Tvl()
	case protocolstat.FieldPools:
		return m.Pools()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProtocolStatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case protocolstat.FieldTotalSupply:
		return m.OldTotalSupply(ctx)
	case protocolstat.FieldTvl:
		return m.OldTvl(ctx)
	case protocolstat.FieldPools:
		return m.OldPools(ctx)
	}
	return nil, fmt.Errorf("unknown ProtocolStat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtocolStatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case protocolstat.FieldTotalSupply:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSupply(v)
		return nil
	case protocolstat.FieldTvl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTvl(v)
		return nil
	case protocolstat.FieldPools:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPools(v)
		return nil
	}
	return fmt.Errorf("unknown ProtocolStat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProtocolStatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProtocolStatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProtocolStatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProtocolStat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProtocolStatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProtocolStatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProtocolStatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProtocolStat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProtocolStatMutation) ResetField(name string) error {
	switch name {
	case protocolstat.FieldTotalSupply:
		m.ResetTotalSupply()
		return nil
	case protocolstat.FieldTvl:
		m.ResetTvl()
		return nil
	case protocolstat.FieldPools:
		m.ResetPools()
		return nil
	}
	return fmt.Errorf("unknown ProtocolStat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProtocolStatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProtocolStatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProtocolStatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProtocolStatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProtocolStatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProtocolStatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProtocolStatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProtocolStat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProtocolStatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProtocolStat edge %s", name)
}

// StableSwapStatMutation represents an operation that mutates the StableSwapStat nodes in the graph.
type StableSwapStatMutation struct {
	config
	op                               Op
	typ                              string
	id                               *string
	totalTokenToStablecoinSwapEvents *string
	totalStablecoinToTokenSwapEvents *string
	remainingDailySwapAmount         *string
	tokenToStablecoinTotalSwapValue  *string
	stablecoinToTokenTotalSwapValue  *string
	clearedFields                    map[string]struct{}
	done                             bool
	oldValue                         func(context.Context) (*StableSwapStat, error)
	predicates                       []predicate.StableSwapStat
}

var _ ent.Mutation = (*StableSwapStatMutation)(nil)

// stableswapstatOption allows management of the mutation configuration using functional options.
type stableswapstatOption func(*StableSwapStatMutation)

// newStableSwapStatMutation creates new mutation for the StableSwapStat entity.
func newStableSwapStatMutation(c config, op Op, opts ...stableswapstatOption) *StableSwapStatMutation {
	m := &StableSwapStatMutation{
		config:        c,
		op:            op,
		typ:           TypeStableSwapStat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStableSwapStatID sets the ID field of the mutation.
func withStableSwapStatID(id string) stableswapstatOption {
	return func(m *StableSwapStatMutation) {
		var (
			err   error
			once  sync.Once
			value *StableSwapStat
		)
		m.oldValue = func(ctx context.Context) (*StableSwapStat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StableSwapStat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStableSwapStat sets the old StableSwapStat of the mutation.
func withStableSwapStat(node *StableSwapStat) stableswapstatOption {
	return func(m *StableSwapStatMutation) {
		m.oldValue = func(context.Context) (*StableSwapStat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StableSwapStatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StableSwapStatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StableSwapStat entities.
func (m *StableSwapStatMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StableSwapStatMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StableSwapStatMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StableSwapStat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTotalTokenToStablecoinSwapEvents sets the "totalTokenToStablecoinSwapEvents" field.
func (m *StableSwapStatMutation) SetTotalTokenToStablecoinSwapEvents(s string) {
	m.totalTokenToStablecoinSwapEvents = &s
}

// TotalTokenToStablecoinSwapEvents returns the value of the "totalTokenToStablecoinSwapEvents" field in the mutation.
func (m *StableSwapStatMutation) TotalTokenToStablecoinSwapEvents() (r string, exists bool) {
	v := m.totalTokenToStablecoinSwapEvents
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTokenToStablecoinSwapEvents returns the old "totalTokenToStablecoinSwapEvents" field's value of the StableSwapStat entity.
// If the StableSwapStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StableSwapStatMutation) OldTotalTokenToStablecoinSwapEvents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTokenToStablecoinSwapEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTokenToStablecoinSwapEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTokenToStablecoinSwapEvents: %w", err)
	}
	return oldValue.TotalTokenToStablecoinSwapEvents, nil
}

// ResetTotalTokenToStablecoinSwapEvents resets all changes to the "totalTokenToStablecoinSwapEvents" field.
func (m *StableSwapStatMutation) ResetTotalTokenToStablecoinSwapEvents() {
	m.totalTokenToStablecoinSwapEvents = nil
}

// SetTotalStablecoinToTokenSwapEvents sets the "totalStablecoinToTokenSwapEvents" field.
func (m *StableSwapStatMutation) SetTotalStablecoinToTokenSwapEvents(s string) {
	m.totalStablecoinToTokenSwapEvents = &s
}

// TotalStablecoinToTokenSwapEvents returns the value of the "totalStablecoinToTokenSwapEvents" field in the mutation.
func (m *StableSwapStatMutation) TotalStablecoinToTokenSwapEvents() (r string, exists bool) {
	v := m.totalStablecoinToTokenSwapEvents
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalStablecoinToTokenSwapEvents returns the old "totalStablecoinToTokenSwapEvents" field's value of the StableSwapStat entity.
// If the StableSwapStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StableSwapStatMutation) OldTotalStablecoinToTokenSwapEvents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalStablecoinToTokenSwapEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalStablecoinToTokenSwapEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalStablecoinToTokenSwapEvents: %w", err)
	}
	return oldValue.TotalStablecoinToTokenSwapEvents, nil
}

// ResetTotalStablecoinToTokenSwapEvents resets all changes to the "totalStablecoinToTokenSwapEvents" field.
func (m *StableSwapStatMutation) ResetTotalStablecoinToTokenSwapEvents() {
	m.totalStablecoinToTokenSwapEvents = nil
}

// SetRemainingDailySwapAmount sets the "remainingDailySwapAmount" field.
func (m *StableSwapStatMutation) SetRemainingDailySwapAmount(s string) {
	m.remainingDailySwapAmount = &s
}

// RemainingDailySwapAmount returns the value of the "remainingDailySwapAmount" field in the mutation.
func (m *StableSwapStatMutation) RemainingDailySwapAmount() (r string, exists bool) {
	v := m.remainingDailySwapAmount
	if v == nil {
		return
	}
	return *v, true
}

// OldRemainingDailySwapAmount returns the old "remainingDailySwapAmount" field's value of the StableSwapStat entity.
// If the StableSwapStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StableSwapStatMutation) OldRemainingDailySwapAmount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemainingDailySwapAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemainingDailySwapAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemainingDailySwapAmount: %w", err)
	}
	return oldValue.RemainingDailySwapAmount, nil
}

// ResetRemainingDailySwapAmount resets all changes to the "remainingDailySwapAmount" field.
func (m *StableSwapStatMutation) ResetRemainingDailySwapAmount() {
	m.remainingDailySwapAmount = nil
}

// SetTokenToStablecoinTotalSwapValue sets the "tokenToStablecoinTotalSwapValue" field.
func (m *StableSwapStatMutation) SetTokenToStablecoinTotalSwapValue(s string) {
	m.tokenToStablecoinTotalSwapValue = &s
}

// TokenToStablecoinTotalSwapValue returns the value of the "tokenToStablecoinTotalSwapValue" field in the mutation.
func (m *StableSwapStatMutation) TokenToStablecoinTotalSwapValue() (r string, exists bool) {
	v := m.tokenToStablecoinTotalSwapValue
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenToStablecoinTotalSwapValue returns the old "tokenToStablecoinTotalSwapValue" field's value of the StableSwapStat entity.
// If the StableSwapStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StableSwapStatMutation) OldTokenToStablecoinTotalSwapValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenToStablecoinTotalSwapValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenToStablecoinTotalSwapValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenToStablecoinTotalSwapValue: %w", err)
	}
	return oldValue.TokenToStablecoinTotalSwapValue, nil
}

// ResetTokenToStablecoinTotalSwapValue resets all changes to the "tokenToStablecoinTotalSwapValue" field.
func (m *StableSwapStatMutation) ResetTokenToStablecoinTotalSwapValue() {
	m.tokenToStablecoinTotalSwapValue = nil
}

// SetStablecoinToTokenTotalSwapValue sets the "stablecoinToTokenTotalSwapValue" field.
func (m *StableSwapStatMutation) SetStablecoinToTokenTotalSwapValue(s string) {
	m.stablecoinToTokenTotalSwapValue = &s
}

// StablecoinToTokenTotalSwapValue returns the value of the "stablecoinToTokenTotalSwapValue" field in the mutation.
func (m *StableSwapStatMutation) StablecoinToTokenTotalSwapValue() (r string, exists bool) {
	v := m.stablecoinToTokenTotalSwapValue
	if v == nil {
		return
	}
	return *v, true
}

// OldStablecoinToTokenTotalSwapValue returns the old "stablecoinToTokenTotalSwapValue" field's value of the StableSwapStat entity.
// If the StableSwapStat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StableSwapStatMutation) OldStablecoinToTokenTotalSwapValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStablecoinToTokenTotalSwapValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStablecoinToTokenTotalSwapValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStablecoinToTokenTotalSwapValue: %w", err)
	}
	return oldValue.StablecoinToTokenTotalSwapValue, nil
}

// ResetStablecoinToTokenTotalSwapValue resets all changes to the "stablecoinToTokenTotalSwapValue" field.
func (m *StableSwapStatMutation) ResetStablecoinToTokenTotalSwapValue() {
	m.stablecoinToTokenTotalSwapValue = nil
}

// Where appends a list predicates to the StableSwapStatMutation builder.
func (m *StableSwapStatMutation) Where(ps ...predicate.StableSwapStat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StableSwapStatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StableSwapStatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StableSwapStat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StableSwapStatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StableSwapStatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StableSwapStat).
func (m *StableSwapStatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StableSwapStatMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.totalTokenToStablecoinSwapEvents != nil {
		fields = append(fields, stableswapstat.FieldTotalTokenToStablecoinSwapEvents)
	}
	if m.totalStablecoinToTokenSwapEvents != nil {
		fields = append(fields, stableswapstat.FieldTotalStablecoinToTokenSwapEvents)
	}
	if m.remainingDailySwapAmount != nil {
		fields = append(fields, stableswapstat.FieldRemainingDailySwapAmount)
	}
	if m.tokenToStablecoinTotalSwapValue != nil {
		fields = append(fields, stableswapstat.FieldTokenToStablecoinTotalSwapValue)
	}
	if m.stablecoinToTokenTotalSwapValue != nil {
		fields = append(fields, stableswapstat.FieldStablecoinToTokenTotalSwapValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StableSwapStatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case stableswapstat.FieldTotalTokenToStablecoinSwapEvents:
		return m.TotalTokenToStablecoinSwapEvents()
	case stableswapstat.FieldTotalStablecoinToTokenSwapEvents:
		return m.TotalStablecoinToTokenSwapEvents()
	case stableswapstat.FieldRemainingDailySwapAmount:
		return m.RemainingDailySwapAmount()
	case stableswapstat.FieldTokenToStablecoinTotalSwapValue:
		return m.TokenToStablecoinTotalSwapValue()
	case stableswapstat.FieldStablecoinToTokenTotalSwapValue:
		return m.StablecoinToTokenTotalSwapValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StableSwapStatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case stableswapstat.FieldTotalTokenToStablecoinSwapEvents:
		return m.OldTotalTokenToStablecoinSwapEvents(ctx)
	case stableswapstat.FieldTotalStablecoinToTokenSwapEvents:
		return m.OldTotalStablecoinToTokenSwapEvents(ctx)
	case stableswapstat.FieldRemainingDailySwapAmount:
		return m.OldRemainingDailySwapAmount(ctx)
	case stableswapstat.FieldTokenToStablecoinTotalSwapValue:
		return m.OldTokenToStablecoinTotalSwapValue(ctx)
	case stableswapstat.FieldStablecoinToTokenTotalSwapValue:
		return m.OldStablecoinToTokenTotalSwapValue(ctx)
	}
	return nil, fmt.Errorf("unknown StableSwapStat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StableSwapStatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case stableswapstat.FieldTotalTokenToStablecoinSwapEvents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTokenToStablecoinSwapEvents(v)
		return nil
	case stableswapstat.FieldTotalStablecoinToTokenSwapEvents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalStablecoinToTokenSwapEvents(v)
		return nil
	case stableswapstat.FieldRemainingDailySwapAmount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemainingDailySwapAmount(v)
		return nil
	case stableswapstat.FieldTokenToStablecoinTotalSwapValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenToStablecoinTotalSwapValue(v)
		return nil
	case stableswapstat.FieldStablecoinToTokenTotalSwapValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStablecoinToTokenTotalSwapValue(v)
		return nil
	}
	return fmt.Errorf("unknown StableSwapStat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StableSwapStatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StableSwapStatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StableSwapStatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StableSwapStat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StableSwapStatMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StableSwapStatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StableSwapStatMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StableSwapStat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StableSwapStatMutation) ResetField(name string) error {
	switch name {
	case stableswapstat.FieldTotalTokenToStablecoinSwapEvents:
		m.ResetTotalTokenToStablecoinSwapEvents()
		return nil
	case stableswapstat.FieldTotalStablecoinToTokenSwapEvents:
		m.ResetTotalStablecoinToTokenSwapEvents()
		return nil
	case stableswapstat.FieldRemainingDailySwapAmount:
		m.ResetRemainingDailySwapAmount()
		return nil
	case stableswapstat.FieldTokenToStablecoinTotalSwapValue:
		m.ResetTokenToStablecoinTotalSwapValue()
		return nil
	case stableswapstat.FieldStablecoinToTokenTotalSwapValue:
		m.ResetStablecoinToTokenTotalSwapValue()
		return nil
	}
	return fmt.Errorf("unknown StableSwapStat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StableSwapStatMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StableSwapStatMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StableSwapStatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StableSwapStatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StableSwapStatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StableSwapStatMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StableSwapStatMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown StableSwapStat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StableSwapStatMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown StableSwapStat edge %s", name)
}

// SwapEventMutation represents an operation that mutates the SwapEvent nodes in the graph.
type SwapEventMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	fee                     *string
	owner                   *string
	value                   *string
	isStablecoinToTokenSwap *bool
	isTokenToStablecoinSwap *bool
	blockNumber             *string
	blockTimestamp          *string
	transaction             *string
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*SwapEvent, error)
	predicates              []predicate.SwapEvent
}

var _ ent.Mutation = (*SwapEventMutation)(nil)

// swapeventOption allows management of the mutation configuration using functional options.
type swapeventOption func(*SwapEventMutation)

// newSwapEventMutation creates new mutation for the SwapEvent entity.
func newSwapEventMutation(c config, op Op, opts ...swapeventOption) *SwapEventMutation {
	m := &SwapEventMutation{
		config:        c,
		op:            op,
		typ:           TypeSwapEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSwapEventID sets the ID field of the mutation.
func withSwapEventID(id string) swapeventOption {
	return func(m *SwapEventMutation) {
		var (
			err   error
			once  sync.Once
			value *SwapEvent
		)
		m.oldValue = func(ctx context.Context) (*SwapEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SwapEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSwapEvent sets the old SwapEvent of the mutation.
func withSwapEvent(node *SwapEvent) swapeventOption {
	return func(m *SwapEventMutation) {
		m.oldValue = func(context.Context) (*SwapEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SwapEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SwapEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SwapEvent entities.
func (m *SwapEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SwapEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SwapEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SwapEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFee sets the "fee" field.
func (m *SwapEventMutation) SetFee(s string) {
	m.fee = &s
}

// Fee returns the value of the "fee" field in the mutation.
func (m *SwapEventMutation) Fee() (r string, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the SwapEvent entity.
// If the SwapEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapEventMutation) OldFee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// ResetFee resets all changes to the "fee" field.
func (m *SwapEventMutation) ResetFee() {
	m.fee = nil
}

// SetOwner sets the "owner" field.
func (m *SwapEventMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *SwapEventMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the SwapEvent entity.
// If the SwapEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapEventMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *SwapEventMutation) ResetOwner() {
	m.owner = nil
}

// SetValue sets the "value" field.
func (m *SwapEventMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SwapEventMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the SwapEvent entity.
// If the SwapEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapEventMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SwapEventMutation) ResetValue() {
	m.value = nil
}

// SetIsStablecoinToTokenSwap sets the "isStablecoinToTokenSwap" field.
func (m *SwapEventMutation) SetIsStablecoinToTokenSwap(b bool) {
	m.isStablecoinToTokenSwap = &b
}

// IsStablecoinToTokenSwap returns the value of the "isStablecoinToTokenSwap" field in the mutation.
func (m *SwapEventMutation) IsStablecoinToTokenSwap() (r bool, exists bool) {
	v := m.isStablecoinToTokenSwap
	if v == nil {
		return
	}
	return *v, true
}

// OldIsStablecoinToTokenSwap returns the old "isStablecoinToTokenSwap" field's value of the SwapEvent entity.
// If the SwapEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapEventMutation) OldIsStablecoinToTokenSwap(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsStablecoinToTokenSwap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsStablecoinToTokenSwap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsStablecoinToTokenSwap: %w", err)
	}
	return oldValue.IsStablecoinToTokenSwap, nil
}

// ResetIsStablecoinToTokenSwap resets all changes to the "isStablecoinToTokenSwap" field.
func (m *SwapEventMutation) ResetIsStablecoinToTokenSwap() {
	m.isStablecoinToTokenSwap = nil
}

// SetIsTokenToStablecoinSwap sets the "isTokenToStablecoinSwap" field.
func (m *SwapEventMutation) SetIsTokenToStablecoinSwap(b bool) {
	m.isTokenToStablecoinSwap = &b
}

// IsTokenToStablecoinSwap returns the value of the "isTokenToStablecoinSwap" field in the mutation.
func (m *SwapEventMutation) IsTokenToStablecoinSwap() (r bool, exists bool) {
	v := m.isTokenToStablecoinSwap
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTokenToStablecoinSwap returns the old "isTokenToStablecoinSwap" field's value of the SwapEvent entity.
// If the SwapEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapEventMutation) OldIsTokenToStablecoinSwap(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTokenToStablecoinSwap is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTokenToStablecoinSwap requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTokenToStablecoinSwap: %w", err)
	}
	return oldValue.IsTokenToStablecoinSwap, nil
}

// ResetIsTokenToStablecoinSwap resets all changes to the "isTokenToStablecoinSwap" field.
func (m *SwapEventMutation) ResetIsTokenToStablecoinSwap() {
	m.isTokenToStablecoinSwap = nil
}

// SetBlockNumber sets the "blockNumber" field.
func (m *SwapEventMutation) SetBlockNumber(s string) {
	m.blockNumber = &s
}

// BlockNumber returns the value of the "blockNumber" field in the mutation.
func (m *SwapEventMutation) BlockNumber() (r string, exists bool) {
	v := m.blockNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockNumber returns the old "blockNumber" field's value of the SwapEvent entity.
// If the SwapEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapEventMutation) OldBlockNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockNumber: %w", err)
	}
	return oldValue.BlockNumber, nil
}

// ResetBlockNumber resets all changes to the "blockNumber" field.
func (m *SwapEventMutation) ResetBlockNumber() {
	m.blockNumber = nil
}

// SetBlockTimestamp sets the "blockTimestamp" field.
func (m *SwapEventMutation) SetBlockTimestamp(s string) {
	m.blockTimestamp = &s
}

// BlockTimestamp returns the value of the "blockTimestamp" field in the mutation.
func (m *SwapEventMutation) BlockTimestamp() (r string, exists bool) {
	v := m.blockTimestamp
	if v == nil {
		return
	}
	return *v, true
}

// OldBlockTimestamp returns the old "blockTimestamp" field's value of the SwapEvent entity.
// If the SwapEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapEventMutation) OldBlockTimestamp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBlockTimestamp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBlockTimestamp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBlockTimestamp: %w", err)
	}
	return oldValue.BlockTimestamp, nil
}

// ResetBlockTimestamp resets all changes to the "blockTimestamp" field.
func (m *SwapEventMutation) ResetBlockTimestamp() {
	m.blockTimestamp = nil
}

// SetTransaction sets the "transaction" field.
func (m *SwapEventMutation) SetTransaction(s string) {
	m.transaction = &s
}

// Transaction returns the value of the "transaction" field in the mutation.
func (m *SwapEventMutation) Transaction() (r string, exists bool) {
	v := m.transaction
	if v == nil {
		return
	}
	return *v, true
}

// OldTransaction returns the old "transaction" field's value of the SwapEvent entity.
// If the SwapEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SwapEventMutation) OldTransaction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransaction: %w", err)
	}
	return oldValue.Transaction, nil
}

// ResetTransaction resets all changes to the "transaction" field.
func (m *SwapEventMutation) ResetTransaction() {
	m.transaction = nil
}

// Where appends a list predicates to the SwapEventMutation builder.
func (m *SwapEventMutation) Where(ps ...predicate.SwapEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SwapEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SwapEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SwapEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SwapEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SwapEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SwapEvent).
func (m *SwapEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SwapEventMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.fee != nil {
		fields = append(fields, swapevent.FieldFee)
	}
	if m.owner != nil {
		fields = append(fields, swapevent.FieldOwner)
	}
	if m.value != nil {
		fields = append(fields, swapevent.FieldValue)
	}
	if m.isStablecoinToTokenSwap != nil {
		fields = append(fields, swapevent.FieldIsStablecoinToTokenSwap)
	}
	if m.isTokenToStablecoinSwap != nil {
		fields = append(fields, swapevent.FieldIsTokenToStablecoinSwap)
	}
	if m.blockNumber != nil {
		fields = append(fields, swapevent.FieldBlockNumber)
	}
	if m.blockTimestamp != nil {
		fields = append(fields, swapevent.FieldBlockTimestamp)
	}
	if m.transaction != nil {
		fields = append(fields, swapevent.FieldTransaction)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SwapEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case swapevent.FieldFee:
		return m.Fee()
	case swapevent.FieldOwner:
		return m.Owner()
	case swapevent.FieldValue:
		return m.Value()
	case swapevent.FieldIsStablecoinToTokenSwap:
		return m.IsStablecoinToTokenSwap()
	case swapevent.FieldIsTokenToStablecoinSwap:
		return m.IsTokenToStablecoinSwap()
	case swapevent.FieldBlockNumber:
		return m.BlockNumber()
	case swapevent.FieldBlockTimestamp:
		return m.BlockTimestamp()
	case swapevent.FieldTransaction:
		return m.Transaction()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SwapEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case swapevent.FieldFee:
		return m.OldFee(ctx)
	case swapevent.FieldOwner:
		return m.OldOwner(ctx)
	case swapevent.FieldValue:
		return m.OldValue(ctx)
	case swapevent.FieldIsStablecoinToTokenSwap:
		return m.OldIsStablecoinToTokenSwap(ctx)
	case swapevent.FieldIsTokenToStablecoinSwap:
		return m.OldIsTokenToStablecoinSwap(ctx)
	case swapevent.FieldBlockNumber:
		return m.OldBlockNumber(ctx)
	case swapevent.FieldBlockTimestamp:
		return m.OldBlockTimestamp(ctx)
	case swapevent.FieldTransaction:
		return m.OldTransaction(ctx)
	}
	return nil, fmt.Errorf("unknown SwapEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SwapEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case swapevent.FieldFee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case swapevent.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case swapevent.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case swapevent.FieldIsStablecoinToTokenSwap:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsStablecoinToTokenSwap(v)
		return nil
	case swapevent.FieldIsTokenToStablecoinSwap:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTokenToStablecoinSwap(v)
		return nil
	case swapevent.FieldBlockNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockNumber(v)
		return nil
	case swapevent.FieldBlockTimestamp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBlockTimestamp(v)
		return nil
	case swapevent.FieldTransaction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransaction(v)
		return nil
	}
	return fmt.Errorf("unknown SwapEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SwapEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SwapEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SwapEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SwapEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SwapEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SwapEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SwapEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SwapEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SwapEventMutation) ResetField(name string) error {
	switch name {
	case swapevent.FieldFee:
		m.ResetFee()
		return nil
	case swapevent.FieldOwner:
		m.ResetOwner()
		return nil
	case swapevent.FieldValue:
		m.ResetValue()
		return nil
	case swapevent.FieldIsStablecoinToTokenSwap:
		m.ResetIsStablecoinToTokenSwap()
		return nil
	case swapevent.FieldIsTokenToStablecoinSwap:
		m.ResetIsTokenToStablecoinSwap()
		return nil
	case swapevent.FieldBlockNumber:
		m.ResetBlockNumber()
		return nil
	case swapevent.FieldBlockTimestamp:
		m.ResetBlockTimestamp()
		return nil
	case swapevent.FieldTransaction:
		m.ResetTransaction()
		return nil
	}
	return fmt.Errorf("unknown SwapEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SwapEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SwapEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SwapEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SwapEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SwapEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SwapEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SwapEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown SwapEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SwapEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown SwapEvent edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	address              *string
	activePositionsCount *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
}

// SetActivePositionsCount sets the "activePositionsCount" field.
func (m *UserMutation) SetActivePositionsCount(s string) {
	m.activePositionsCount = &s
}

// ActivePositionsCount returns the value of the "activePositionsCount" field in the mutation.
func (m *UserMutation) ActivePositionsCount() (r string, exists bool) {
	v := m.activePositionsCount
	if v == nil {
		return
	}
	return *v, true
}

// OldActivePositionsCount returns the old "activePositionsCount" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActivePositionsCount(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActivePositionsCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActivePositionsCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActivePositionsCount: %w", err)
	}
	return oldValue.ActivePositionsCount, nil
}

// ResetActivePositionsCount resets all changes to the "activePositionsCount" field.
func (m *UserMutation) ResetActivePositionsCount() {
	m.activePositionsCount = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.activePositionsCount != nil {
		fields = append(fields, user.FieldActivePositionsCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldAddress:
		return m.Address()
	case user.FieldActivePositionsCount:
		return m.ActivePositionsCount()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldActivePositionsCount:
		return m.OldActivePositionsCount(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldActivePositionsCount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActivePositionsCount(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldActivePositionsCount:
		m.ResetActivePositionsCount()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
