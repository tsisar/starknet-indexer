package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.74

import (
	"context"
	"fmt"

	"github.com/tsisar/starknet-indexer/generated/ent"
	"github.com/tsisar/starknet-indexer/generated/ent/pool"
	"github.com/tsisar/starknet-indexer/generated/ent/position"
	"github.com/tsisar/starknet-indexer/generated/ent/positionactivity"
	"github.com/tsisar/starknet-indexer/generated/ent/protocolstat"
	"github.com/tsisar/starknet-indexer/generated/ent/stableswapstat"
	"github.com/tsisar/starknet-indexer/generated/ent/swapevent"
	"github.com/tsisar/starknet-indexer/generated/ent/user"
	"github.com/tsisar/starknet-indexer/graphql/model"
	"github.com/tsisar/starknet-indexer/graphql/resolvers"
	"github.com/tsisar/starknet-indexer/internal/config"
	storage "github.com/tsisar/starknet-indexer/internal/storage/model"
)

// Meta is the resolver for the _Meta field.
func (r *queryResolver) Meta(ctx context.Context) (*model.Meta, error) {
	var status storage.Status

	if err := r.DB.WithContext(ctx).
		Limit(1).
		Find(&status).Error; err != nil {
		return nil, fmt.Errorf("failed to query status: %w", err)
	}

	meta := &model.Meta{
		Block: &model.Block{
			Hash:       status.Hash,
			ParentHash: "",
			Number:     fmt.Sprintf("%d", status.CurrentBlock),
			Timestamp:  fmt.Sprintf("%d", status.Timestamp),
		},
		Deployment:        fmt.Sprintf("starknet-stablecoin-indexer-%s", config.App.Version),
		HasIndexingErrors: fmt.Sprintf("%t", status.HasError),
	}

	return meta, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id *string) (*ent.User, error) {
	query := r.Client.User.Query()

	if id != nil {
		query = query.Where(user.IDEQ(*id))
	} else {
		return nil, fmt.Errorf("id is required")
	}
	return query.Only(ctx)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, where *model.UserWhereInput, orderBy *model.UserOrderBy, first *int32, skip *int32) ([]*ent.User, error) {
	query := r.Client.User.Query()

	query = resolvers.ApplyUserWhereInput(query, where)
	query = resolvers.ApplyUserOrderBy(query, orderBy)
	query = resolvers.ApplyUserLimit(query, first, skip)

	return query.All(ctx)
}

// Pool is the resolver for the pool field.
func (r *queryResolver) Pool(ctx context.Context, id *string) (*ent.Pool, error) {
	query := r.Client.Pool.Query()

	if id != nil {
		query = query.Where(pool.IDEQ(*id))
	} else {
		return nil, fmt.Errorf("id is required")
	}
	return query.Only(ctx)
}

// Pools is the resolver for the pools field.
func (r *queryResolver) Pools(ctx context.Context, where *model.PoolWhereInput, orderBy *model.PoolOrderBy, first *int32, skip *int32) ([]*ent.Pool, error) {
	query := r.Client.Pool.Query()

	query = resolvers.ApplyPoolWhereInput(query, where)
	query = resolvers.ApplyPoolOrderBy(query, orderBy)
	query = resolvers.ApplyPoolLimit(query, first, skip)

	return query.All(ctx)
}

// ProtocolStat is the resolver for the protocolStat field.
func (r *queryResolver) ProtocolStat(ctx context.Context, id *string) (*ent.ProtocolStat, error) {
	query := r.Client.ProtocolStat.Query()

	if id != nil {
		query = query.Where(protocolstat.IDEQ(*id))
	} else {
		return nil, fmt.Errorf("id is required")
	}
	return query.Only(ctx)
}

// ProtocolStats is the resolver for the protocolStats field.
func (r *queryResolver) ProtocolStats(ctx context.Context, where *model.ProtocolStatWhereInput, orderBy *model.ProtocolStatOrderBy, first *int32, skip *int32) ([]*ent.ProtocolStat, error) {
	query := r.Client.ProtocolStat.Query()

	query = resolvers.ApplyProtocolStatWhereInput(query, where)
	query = resolvers.ApplyProtocolStatOrderBy(query, orderBy)
	query = resolvers.ApplyProtocolStatLimit(query, first, skip)

	return query.All(ctx)
}

// Position is the resolver for the position field.
func (r *queryResolver) Position(ctx context.Context, id *string) (*ent.Position, error) {
	query := r.Client.Position.Query()

	if id != nil {
		query = query.Where(position.IDEQ(*id))
	} else {
		return nil, fmt.Errorf("id is required")
	}
	return query.Only(ctx)
}

// Positions is the resolver for the positions field.
func (r *queryResolver) Positions(ctx context.Context, where *model.PositionWhereInput, orderBy *model.PositionOrderBy, first *int32, skip *int32) ([]*ent.Position, error) {
	query := r.Client.Position.Query()

	query = resolvers.ApplyPositionWhereInput(query, where)
	query = resolvers.ApplyPositionOrderBy(query, orderBy)
	query = resolvers.ApplyPositionLimit(query, first, skip)

	return query.All(ctx)
}

// PositionActivity is the resolver for the positionActivity field.
func (r *queryResolver) PositionActivity(ctx context.Context, id *string) (*ent.PositionActivity, error) {
	query := r.Client.PositionActivity.Query()

	if id != nil {
		query = query.Where(positionactivity.IDEQ(*id))
	} else {
		return nil, fmt.Errorf("id is required")
	}
	return query.Only(ctx)
}

// PositionActivities is the resolver for the positionActivities field.
func (r *queryResolver) PositionActivities(ctx context.Context, where *model.PositionActivityWhereInput, orderBy *model.PositionActivityOrderBy, first *int32, skip *int32) ([]*ent.PositionActivity, error) {
	query := r.Client.PositionActivity.Query()

	query = resolvers.ApplyPositionActivityWhereInput(query, where)
	query = resolvers.ApplyPositionActivityOrderBy(query, orderBy)
	query = resolvers.ApplyPositionActivityLimit(query, first, skip)

	return query.All(ctx)
}

// SwapEvent is the resolver for the swapEvent field.
func (r *queryResolver) SwapEvent(ctx context.Context, id *string) (*ent.SwapEvent, error) {
	query := r.Client.SwapEvent.Query()

	if id != nil {
		query = query.Where(swapevent.IDEQ(*id))
	} else {
		return nil, fmt.Errorf("id is required")
	}
	return query.Only(ctx)
}

// SwapEvents is the resolver for the swapEvents field.
func (r *queryResolver) SwapEvents(ctx context.Context, where *model.SwapEventWhereInput, orderBy *model.SwapEventOrderBy, first *int32, skip *int32) ([]*ent.SwapEvent, error) {
	query := r.Client.SwapEvent.Query()

	query = resolvers.ApplySwapEventWhereInput(query, where)
	query = resolvers.ApplySwapEventOrderBy(query, orderBy)
	query = resolvers.ApplySwapEventLimit(query, first, skip)

	return query.All(ctx)
}

// StableSwapStat is the resolver for the stableSwapStat field.
func (r *queryResolver) StableSwapStat(ctx context.Context, id *string) (*ent.StableSwapStat, error) {
	query := r.Client.StableSwapStat.Query()

	if id != nil {
		query = query.Where(stableswapstat.IDEQ(*id))
	} else {
		return nil, fmt.Errorf("id is required")
	}
	return query.Only(ctx)
}

// StableSwapStats is the resolver for the stableSwapStats field.
func (r *queryResolver) StableSwapStats(ctx context.Context, where *model.StableSwapStatWhereInput, orderBy *model.StableSwapStatOrderBy, first *int32, skip *int32) ([]*ent.StableSwapStat, error) {
	query := r.Client.StableSwapStat.Query()

	query = resolvers.ApplyStableSwapStatWhereInput(query, where)
	query = resolvers.ApplyStableSwapStatOrderBy(query, orderBy)
	query = resolvers.ApplyStableSwapStatLimit(query, first, skip)

	return query.All(ctx)
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
